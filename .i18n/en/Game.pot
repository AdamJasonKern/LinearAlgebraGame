msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Jun 11 19:34:15 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\"."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Most levels in this game will require you to prove a mathematical theorem. In the middle of the\n"
"screen, you will see your \"Active Goal\", which includes \"Objects:\" `x: ‚Ñù` and a \"Goal\" `x=x`.\n"
"In later levels, you may also get a \"Assumptions\" line. Your objects and assumptions are what you\n"
"have to work with. In this case, we know that `x` is in  `‚Ñù`, which means `x` is a real number.\n"
"From this, we have to prove our goal, that `x=x`.\n"
"\n"
"The first tactic we will use is the `rfl` tactic. `rfl` stands for \"reflexivity\". `rfl` will solve\n"
"goals when the left side of an equation is the same as the right side, at least up to definitions."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Try typing 'rfl' into the text box below, then hit \"Execute\". This should finish the proof."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "You have now finished your first proof in Lean 4! In future levels, you can also use the 'rfl' tactic.\n"
"You can click on the 'rfl' box on the right side to learn more about the 'rfl' tactic.\n"
"\n"
"Click on \"Next\" to go to the next level."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The rewrite (rw) tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targeted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The second tactic we will look at is the rewrite tactic. This tactic is how you \"substitute in\"\n"
"a value for something you know is equal. If you have an assumption `h: A=B`, and your goal is to\n"
"prove something about `A`, you can replace `A` with `B`, since they are equal.\n"
"\n"
"In this level, the goal is to prove `2 * y = 2 * (x + 7)`. You also have an assumption `h: y = x + 7`.\n"
"Writing `rw[h]` will rewrite `y` as `x + 7` in the goal.\n"
"\n"
"Also note that the `rw` tactic will automatically attempt the `rfl` tactic after it rewrites, so if\n"
"after the rewrite the goal is of the form `X = X`, it will automatically be solved."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "Try using `rw [h]` to solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "You now know the two most basic tactics in Lean! Again, you can click on `rw` on the right hand side\n"
"to see more about the tactic.\n"
"\n"
"Click on \"Next\" to go to the next level!"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "The `intro` and `exact` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"Intro introduces a new hypothesis and changes your goal. If you have a goal of the form `P ‚Üí Q`,\n"
"`intro h` will change the goal to `Q` and create a new hypothesis `h : P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x = 1 ‚Üí x + x = 2`, `intro h` will create the hypothesis `h: x = 1`, and change the\n"
"goal to `x + x = 2`.\n"
"\n"
"## Other usage\n"
"\n"
"The `intro` tactic also works with goals using `‚àÄ` (\\\"for all\\\"). If your goal is of the form `‚àÄ x : T, P`,\n"
"`intro x` will create a new variable `x : T`, and change the goal to `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `‚àÄ x : Nat, x ‚â• 0`, `intro x` will create a variable `x : Nat`, and change the goal\n"
"to `x ‚â• 0`."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will solve the goal if `h` is a proof of `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x + 5 = 10`, and you have a hypothesis `h: x + 5 = 10`, then `exact h` will solve\n"
"the goal.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x ‚¨ù y = 0 ‚Üî x ‚üÇ y`, and you have a theorem `dot_zero_iff_perp` that states the same\n"
"thing, `exact dot_zero_iff_perp` will solve the goal.\n"
"\n"
"## exact? tactic\n"
"\n"
"`exact` has a variation, `exact?`, that is very useful. If your goal seems very obvious, and if you\n"
"believe that there is a theorem or hypothesis that is exactly the same as your goal, `exact?` will\n"
"attempt to fill in an `exact` tactic. This way, you don't have to memorize the exact statement of\n"
"every theorem in order to finish a proof.\n"
"However, with great power comes great responsibility, and using `exact?` too often can obscure how\n"
"a proof actually works, and can lead you to being more confused than when you started."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "In this level, we will introduce two tactics: `intro`, and `exact`\n"
"Our goal is to prove that for any proposition (a True/False statement) `P`, we know that `P ‚Üí P`.\n"
"This means that `P` implies `P`.\n"
"\n"
"To explain what implication means more rigorously, if we know that `P ‚Üí Q`, whenever `P` is True, we\n"
"now know that `Q` must also be True. A computer scientist can consider a proof that `P ‚Üí Q` as a function\n"
"taking proofs of `P` to proofs of `Q`. In Lean, this means that we take an arbitrary proof of `P`,\n"
"say `h: P` and we must construct a proof of `Q` from it.\n"
"\n"
"### Intro\n"
"This idea is exatly what the `intro` tactic does. If the goal is of the form `P ‚Üí Q`, `intro h` will\n"
"create a new hypothesis `h: P`, and change the goal into `Q`.\n"
"\n"
"### Exact\n"
"The exact tactic is the other tactic you will need to solve this level. If you have a hypothesis that\n"
"is exactly the same as the goal, the exact tactic will solve the goal. For example, if your goal is\n"
"`P`, and you have a hypothesis `h: P`, `exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "First use `intro` to give yourself a new assumption and simplify the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Now use `exact` to solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "You now know how to use the `intro` and `exact` tactics!"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "The `constructor` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "## Summary\n"
"\n"
"The constructor tactic splits the goal into multiple parts. This is helpful for goals that are\n"
"difficult to solve all at once, like \"and\" (`‚àß`) and \"if and only if\" (`‚Üî`).\n"
"\n"
"## Example\n"
"\n"
"If we have the goal `P ‚àß Q`, `constructor` will change the goal into two goals: `P` and `Q`.\n"
"\n"
"## Example\n"
"\n"
"If we have the goal`P ‚Üî Q`, `constructor` will change the goal into two goals: `P ‚Üí Q`, and `Q ‚Üí P`."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "In this level we will learn `constructor` in the context of logical 'and' (‚àß).\n"
"Our goal is to prove `P ‚àß Q`, \"P and Q\", given hypotheses `p: P` and `q: Q`.\n"
"\n"
"### Constructor:\n"
"\n"
"The `constructor` tactic works by splitting up the goal. If you have a goal `P ‚àß Q`, the tactic makes\n"
"progress by turning this one goal into two goals: to prove `P` and to prove `Q`. Constructor also\n"
"works similarly for `‚Üî` \"if and only if\" goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try using `constructor` to split up the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Both remaining goals are exactly your hypotheses. What tactic can solve the goals?"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "You can now prove goals by splitting them into multiple steps with the `constructor` tactic!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "The `unfold` and `apply` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If we have some object or function with some definition, `unfold object` will rewrite the object\n"
"with its definition everywhere. Lean often unfolds terms automatically, but some tactics and definitions\n"
"are not unfolded automatically. The `unfold` tactic also helps make it easier to take the next steps.\n"
"\n"
"## Example:\n"
"\n"
"If you have a goal `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`, with `¬¨ P` (\\\"Not\\\" P) being defined as `P ‚Üí False`,\n"
"using `unfold Not` will change the goal to `(P ‚Üí Q) ‚Üí ((Q ‚Üí False) ‚Üí (P ‚Üí False))`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"`intros` acts very similar to the `intro` tactic, except it allows you to introduce many new\n"
"hypotheses/variables at once. `intros h1 h2 h3` essentially acts as `intro h1; intro h2; intro h3;`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `P ‚Üí Q ‚Üí (‚àÄ x : Nat, R ‚Üí (x = 5))`, `intros p q x r` will create hypotheses `p: P`,\n"
"`q: Q`, `r: R`, and a variable `x: Nat`, and change the goal to `x = 5`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "In this level, we will learn the `unfold` and `apply` tactics. Our goal is to prove `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`,\n"
"which looks very messy and difficult, but it can be slowly unfolded and broken down into simple steps.\n"
"\n"
"The first tactic we will need is `unfold`. You may notice the `¬¨` symbol appearing multiple times in\n"
"the goal. This symbol means \"Not\", so `¬¨P` means \"not P\", or that P is false. In Lean, this is\n"
"encoded as `P ‚Üí False`.\n"
"\n"
"### Unfold\n"
"The `unfold` tactic will unfold definitions. Think of it as a big `rw` tactic that rewrites something\n"
"with it's definition everywhere. In this level, `unfold Not` will replace all the `¬¨ P`s with `P ‚Üí False`.\n"
"\n"
"We know how to deal with statements of the form `P ‚Üí Q` in the goal, but what happens if we have them\n"
"as hypotheses? In this case, we will need the `apply` tactic.\n"
"\n"
"### Apply\n"
"The `apply` tactic applies a hypothesis of the form `P ‚Üí Q` to the goal. If your goal is `Q`, and\n"
"you have a hypothesis `h: P ‚Üí Q`, `apply h` will change the goal to `P`.\n"
"\n"
"### Combining hypotheses\n"
"Another way to use `h: P ‚Üí Q` hypotheses is that if you also have another hypothesis  `h2: P`,\n"
"`h h2` will be a proof of `Q`. So, if you have these two hypotheses, and your goal is `Q`, `exact h h2`\n"
"will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try using `unfold Not` to unfold the definition of `¬¨`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since there is a hypothesis also with a `¬¨` symbol, `unfold Not at *` will unfold\n"
"everywhere!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since you goal is of the form `P ‚Üí Q`, the `intro` tactic may help."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "You can still use the `intro` tactic because the goal is still of the form `P ‚Üí Q`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, try the `apply` tactic. Remember that if your goal is `Q`, you can use `apply h` when\n"
"h is a hypothesis or proof that `P ‚Üí Q`. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Again, try the `apply` tactic to change the goal. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "This theorem shows that a statement `P ‚Üí Q` implies its contrapositive `¬¨Q ‚Üí ¬¨P`. In fact, these\n"
"two statements are the same, and you can prove `(P ‚Üí Q) ‚Üî (¬¨ Q ‚Üí ¬¨ P)`\n"
"\n"
"Also, instead of writing intro three times, you can write `intros h1 h2 h3`, and that will be the\n"
"same as `intro h1; intro h2; intro h3`."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "The `cases'` and `exfalso` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases' h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `h : P ‚à® Q` is a hypothesis, then `cases' h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases' h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"\n"
"## Example\n"
"\n"
"If `h : ‚àÉ (a : ‚Ñù), a * a = 0` is a hypothesis, thatn `cases' h with a ha` will create a variable\n"
"`a : Nat` and a hypothesis `ha : a * a = 0`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"`exfalso` changes any goal to `False` this works because proving `False` is a contradiction and can\n"
"thus prove anything else. Mathematically, this means that for any proposition `P`, `False ‚Üí P`.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "This level introduces the `cases'` and `exfalso` tactics. The goal of this level is to prove `(P ‚àß ¬¨ P) ‚Üí Q`.\n"
"This proof is similar to a proof by contradiction. The first part of the implication, `P ‚àß ¬¨ P`, is\n"
"a contradiction, so it can prove any proposition `Q`.\n"
"\n"
"### Cases'\n"
"The `cases'` tactic is very important in Lean. It allows you to split any object or hypothesis into\n"
"cases. In this level, we will eventually have an and statement as a hypothesis. If we have `h: P ‚àß Q`,\n"
"`cases' h with hL hR` will create two hypotheses: `hL: P`, and `hR: Q`. If you have an object `x` that\n"
"can be split into cases, `cases' x with c1 c2` will split `x` into cases called `c1` and `c2`.\n"
"\n"
"### Exfalso\n"
"The `exfalso` tactic is also useful in this level. It simply changes the goal to `False`. This works\n"
"because if you can prove `False`, you have a contradiction, and can thus prove any statements. For\n"
"example, if you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You have two main options here. Note that you have a statement of the form `P ‚Üí Q`, so there\n"
"is a tactic we know that can simplify the goal. Also, we have a `¬¨` character, so unfolding that\n"
"could also be helpful"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Since the `¬¨` symbol is in a hypothesis now, instead of the goal, in order to unfold it you\n"
"need to do `unfold Not at h`, where you replace `h` with the name of your hypothesis. `unfold Not\n"
"at *` will also unfold it everywhere."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Now, use the `cases'` tactic to split up your and statement hypothesis."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "It would be nice if our goal was `False` here."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You now know most of the basics for working with logic in Lean! The remaining levels in the tutorial\n"
"world will move away from pure logic, but many of the tactics used already will still be essential."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "## Summary\n"
"The `linarith` tactic simplifies the goal by using the hypotheses. It works well on linear inequalities\n"
"and equalities. It works by looking for contradictions, although the actual algorithmic implementation\n"
"is very complicated.\n"
"\n"
"## Example\n"
"\n"
"If you have a bunch of hypotheses like h1 : a < b, h2 : b <= c, h3 : c = d and a goal of a < d,\n"
"then linarith will solve it. Linarith knows how to combine linear relations: it knows a ton of\n"
"results about how to put inequalities together and will close such goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic aims to simplify the process of proofs. Specifically, it solves certain kinds\n"
"of linear equalities and inequalities. It attempts to solve or simplify the goal using the hypotheses\n"
"and certain properties of the numbers you are working with."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "In this level, simply trying `linarith` should solve the level."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "Linarith is very useful to simplify goals involving linear terms."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "### Summary\n"
"\n"
"The `simp` tactic tries to simplify the goal, and will solve it if possible. It acts similar to the\n"
"`rw` tactic, although it is able to rewrite with many different statements many times in order to\n"
"simplify the goal. `simp` will try to use all the theorems available if not told explicitly what\n"
"theorems to use.\n"
"\n"
"Using `simp only [tactic1, tactic2, ...]` will simplify only using the theorems listed.\n"
"\n"
"### Example\n"
"\n"
"If your goal is something simple like `0 + 0 = 0`, `simp` will know enough about the natural numbers\n"
"to solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If your goal is `(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h`, which seems\n"
"complicated, but you only need to use associativity and commutativity of addition,\n"
"`simp only [add_assoc, add_left_comm, add_comm]` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic aims to simplify your goal. Often if a goal seems very complicated, or uses\n"
"definitions that need to be unfolded, the `simp` tactic will make progress.\n"
"\n"
"`simp` is not a flawless tool, and there are many simple statements it cannot prove, although when\n"
"used correctly, it can be very useful.\n"
"\n"
"In this level, your goal is to prove an equality about certain elements in a \"Group\". A group is a\n"
"mathematical object where elements in a group can be multiplied together in a way that \"makes sense\".\n"
"Examples of groups involve the real numbers, integers, invertible square matrices of a specific size,\n"
"and many more. `simp` knows many theorems about groups, and is able to simplify and solve most\n"
"simple statements about them.\n"
"\n"
"In this level, `a b c` are all elements of G, `1` is the multiplicative identity of G, and `a‚Åª¬π` is\n"
"the multiplicative inverse of `a`. You can see that both sides of the equation will cancel out to `b`,\n"
"but there is an easy way to prove that they are equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "Just typing `simp` will solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "`simp` will be very useful when solving simple equations in future worlds. You can always\n"
"read more about it by clicking on it on the right."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "The `use` tactic and your first theorem"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a ‚â§ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a ‚â§ b` by `use`ing the\n"
"number which is morally `b - a` (i.e. `use b - a`)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the `use` function is accurate:\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "le_iff_exists_add is a proof that `a ‚â§ b ‚Üî ‚àÉ (c : ‚Ñï), a = b + c`.\n"
"\n"
"The reason for the name is that two numbers are less than or equal to each other if and only if\n"
"there exists a number that you can add to the smaller one to make them equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "In this level, the goal is to prove `x ‚â§ 1 + x`. This requires understanding how to prove statements\n"
"about inequalities. We can define the `‚â§` symbol so that `a ‚â§ b` means `‚àÉ (c : ‚Ñï), b = a + c`. In\n"
"other words, a is less than or equal to b if and only if there exists a natural number c where\n"
"b = a + c. In this level, we have decided to use the natural numbers, although the statement is\n"
"clearly also true when working with real numbers. This is because the theorem \"le_iff_exists_add\"\n"
"does not work with the real numbers, so the proof would be slightly different.\n"
"\n"
"We have this statment as a theorem, \"le_iff_exists_add\".\n"
"\n"
"However, note that this theorem will rewrite the goal to have a `‚àÉ` symbol. In this case, we have to\n"
"find a number that satisfies a certain property. Once you find such a number, you can use the `use`\n"
"tactic.\n"
"\n"
"`use c` changes the goal from the form `‚àÉ x, Property(x)` to `Property(c)`. This allows you to solve\n"
"`‚àÉ` goals, but you need to first find a valid example, which may take some planing ahead."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try using the new theorem! Since it is a proof of `‚Üî`, the rewrite tactic should work!"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "What number should you use here to make the statement true?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "You now have a simple linear equation. What tactic can solve linear equations and prove\n"
"equalities?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Now on to the last level in the tutorial world!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction' n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction' n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "'add_succ' is a proof that `n + Nat.succ m = Nat.succ (n + m)`.\n"
"\n"
"The reason for the name is that the theorem proves that adding the successor of a number is equal to\n"
"the successor of addind that number."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic is a powerful tool to help you to prove statments involving natural numbers.\n"
"It splits a proof into two cases: a base case and an inductive step. The base case is the smallest\n"
"natural number you need to prove the proof for. The inductive step proves the theorem for all other\n"
"numbers. In the inductive step, you can assume the theorem holds for some value `d`, and must then\n"
"prove that it holds for `d + 1`, also written as `Nat.succ d`, the successor of `d`. Induction can\n"
"also be used to prove theorems about objects indexed my natural numbers, such as vectors whose\n"
"dimension can be described by a natural number.\n"
"\n"
"The syntax for the `induction'` tactic is `induction' n with d hd`. As long as `n` is an arbirtary\n"
"natural number in the proof, this will do induction on `n`, where `d` is the number you assume the\n"
"theorem holds for in the inductive step, and `hd` is the induction hypothesis you will get.\n"
"\n"
"This level also uses a new theorem: `add_succ`. `add_succ` is a proof that\n"
"`n + Nat.succ m = Nat.succ (n + m)`, for any `n, m : ‚Ñï`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "First, perform induction on `n`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, for the base case, you need to prove a simple property of the naturals."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "You are adding the successor of a number here, try to simplify this using the new theorem!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, use the inductive hypothesis to finish the proof!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"You have now finished Tutorial World! Now, you can move on to Vector Space world.\n"
"\n"
"The future worlds will be more challenging than this one, and will use less hints. However, if you're\n"
"stuck on how a tactic or theorem works, you can always read what they do on the right, or return to\n"
"Tutorial World for more review!\n"
"\n"
"Click \"Leave World\" to return to the main menu."
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Tutorial World"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Welcome to the tutorial world! This world is designed to indroduce you to Lean 4.\n"
"\n"
"In this world, we start with proving 'x=x', and then move on to solve basic logic problems and\n"
"simple theorems about the natural numbers.\n"
"\n"
"If you already know how to use Lean 4, you can skip this world, although we recommend playing through it.\n"
"\n"
"Click start to begin solving your first level!"
msgstr ""

#: Game
msgid "Linear Algebra Game"
msgstr ""

#: Game
msgid "# Welcome to the Linear Algebra Game!\n"
"\n"
"This game works as a learning tool for linear algebra,\n"
"based on the textbook \"Linear Algebra Done Right\" by Sheldon Axler. It also serves as an\n"
"introduction to Lean 4, a proof assistant that provides an environment to encode proofs formally.\n"
"\n"
"Proofs in Lean can are written in precise syntax, using tactics and theorems, and can be algorithmically\n"
"checked for correctness by a computer.\n"
"\n"
"This game covers many areas of linear algebra, including vector spaces, linear independence, bases,\n"
"linear mappings, and isomorphisms.\n"
"\n"
"To start, click on \"Tutorial World\""
msgstr ""

#: Game
msgid "*Game version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Team:** Huiyu Chen, Adam Kern, Justin Morrill, and Letian Yang\n"
"* **Project Manager:** Daniel Zhou\n"
"* **Project Leader:** Professor Colleen Robles\n"
"* **2023 Lean 3 Version:** Yannan Bai, Annapurna Bhattacharya, Chun-Hsien Hsu, Stavan Jain, Kurt Ma, Ricardo Prado Cunha, Anoushka Sinha\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Inspiration:** Kevin Buzzard's Natural Number Game (https://adam.math.hhu.de/#/g/leanprover-community/nng4)"
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
