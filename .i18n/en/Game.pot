msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Jul 10 16:06:45 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\"."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Most levels in this game will require you to prove a mathematical theorem. In the middle of the\n"
"screen, you will see your \"Active Goal\", which includes \"Objects:\" `x: ‚Ñù` and a \"Goal\" `x=x`.\n"
"In later levels, you may also get a \"Assumptions\" line. Your objects and assumptions are what you\n"
"have to work with. In this case, we know that `x` is in  `‚Ñù`, which means `x` is a real number.\n"
"From this, we have to prove our goal, that `x=x`.\n"
"\n"
"The first tactic we will use is the `rfl` tactic. `rfl` stands for \"reflexivity\". `rfl` will solve\n"
"goals when the left side of an equation is the same as the right side, at least up to definitions."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "Try typing 'rfl' into the text box below, then hit \"Execute\". This should finish the proof."
msgstr ""

#: Game.Levels.TutorialWorld.Level01
msgid "You have now finished your first proof in Lean 4! In future levels, you can also use the 'rfl' tactic.\n"
"You can click on the 'rfl' box on the right side to learn more about the 'rfl' tactic.\n"
"\n"
"Click on \"Next\" to go to the next level."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The rewrite (rw) tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rw 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targeted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rw 37 [h]`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rw \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rw 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rw 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rw 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rw 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "The second tactic we will look at is the rewrite tactic. This tactic is how you \"substitute in\"\n"
"a value for something you know is equal. If you have an assumption `h: A=B`, and your goal is to\n"
"prove something about `A`, you can replace `A` with `B`, since they are equal.\n"
"\n"
"In this level, the goal is to prove `2 * y = 2 * (x + 7)`. You also have an assumption `h: y = x + 7`.\n"
"Writing `rw[h]` will rewrite `y` as `x + 7` in the goal.\n"
"\n"
"Also note that the `rw` tactic will automatically attempt the `rfl` tactic after it rewrites, so if\n"
"after the rewrite the goal is of the form `X = X`, it will automatically be solved."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "Try using `rw [h]` to solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level02
msgid "You now know the two most basic tactics in Lean! Again, you can click on `rw` on the right hand side\n"
"to see more about the tactic.\n"
"\n"
"Click on \"Next\" to go to the next level!"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "The `intro` and `exact` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"Intro introduces a new hypothesis and changes your goal. If you have a goal of the form `P ‚Üí Q`,\n"
"`intro h` will change the goal to `Q` and create a new hypothesis `h : P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x = 1 ‚Üí x + x = 2`, `intro h` will create the hypothesis `h: x = 1`, and change the\n"
"goal to `x + x = 2`.\n"
"\n"
"## Other usage\n"
"\n"
"The `intro` tactic also works with goals using `‚àÄ` (\\\"for all\\\"). If your goal is of the form `‚àÄ x : T, P`,\n"
"`intro x` will create a new variable `x : T`, and change the goal to `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `‚àÄ x : Nat, x ‚â• 0`, `intro x` will create a variable `x : Nat`, and change the goal\n"
"to `x ‚â• 0`."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will solve the goal if `h` is a proof of `P`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x + 5 = 10`, and you have a hypothesis `h: x + 5 = 10`, then `exact h` will solve\n"
"the goal.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `x ‚¨ù y = 0 ‚Üî x ‚üÇ y`, and you have a theorem `dot_zero_iff_perp` that states the same\n"
"thing, `exact dot_zero_iff_perp` will solve the goal.\n"
"\n"
"## exact? tactic\n"
"\n"
"`exact` has a variation, `exact?`, that is very useful. If your goal seems very obvious, and if you\n"
"believe that there is a theorem or hypothesis that is exactly the same as your goal, `exact?` will\n"
"attempt to fill in an `exact` tactic. This way, you don't have to memorize the exact statement of\n"
"every theorem in order to finish a proof.\n"
"However, with great power comes great responsibility, and using `exact?` too often can obscure how\n"
"a proof actually works, and can lead you to being more confused than when you started."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "In this level, we will introduce two tactics: `intro`, and `exact`\n"
"Our goal is to prove that for any proposition (a True/False statement) `P`, we know that `P ‚Üí P`.\n"
"This means that `P` implies `P`.\n"
"\n"
"To explain what implication means more rigorously, if we know that `P ‚Üí Q`, whenever `P` is True, we\n"
"now know that `Q` must also be True. A computer scientist can consider a proof that `P ‚Üí Q` as a function\n"
"taking proofs of `P` to proofs of `Q`. In Lean, this means that we take an arbitrary proof of `P`,\n"
"say `h: P` and we must construct a proof of `Q` from it.\n"
"\n"
"### Intro\n"
"This idea is exatly what the `intro` tactic does. If the goal is of the form `P ‚Üí Q`, `intro h` will\n"
"create a new hypothesis `h: P`, and change the goal into `Q`.\n"
"\n"
"### Exact\n"
"The exact tactic is the other tactic you will need to solve this level. If you have a hypothesis that\n"
"is exactly the same as the goal, the exact tactic will solve the goal. For example, if your goal is\n"
"`P`, and you have a hypothesis `h: P`, `exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "First use `intro` to give yourself a new assumption and simplify the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "Now use `exact` to solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level03
msgid "You now know how to use the `intro` and `exact` tactics!"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "The `constructor` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "## Summary\n"
"\n"
"The constructor tactic splits the goal into multiple parts. This is helpful for goals that are\n"
"difficult to solve all at once, like \"and\" (`‚àß`) and \"if and only if\" (`‚Üî`).\n"
"\n"
"## Example\n"
"\n"
"If we have the goal `P ‚àß Q`, `constructor` will change the goal into two goals: `P` and `Q`.\n"
"\n"
"## Example\n"
"\n"
"If we have the goal`P ‚Üî Q`, `constructor` will change the goal into two goals: `P ‚Üí Q`, and `Q ‚Üí P`."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "In this level we will learn `constructor` in the context of logical 'and' (‚àß).\n"
"Our goal is to prove `P ‚àß Q`, \"P and Q\", given hypotheses `p: P` and `q: Q`.\n"
"\n"
"### Constructor:\n"
"\n"
"The `constructor` tactic works by splitting up the goal. If you have a goal `P ‚àß Q`, the tactic makes\n"
"progress by turning this one goal into two goals: to prove `P` and to prove `Q`. Constructor also\n"
"works similarly for `‚Üî` \"if and only if\" goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Try using `constructor` to split up the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "Both remaining goals are exactly your hypotheses. What tactic can solve the goals?"
msgstr ""

#: Game.Levels.TutorialWorld.Level04
msgid "You can now prove goals by splitting them into multiple steps with the `constructor` tactic!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "The `unfold` and `apply` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If we have some object or function with some definition, `unfold object` will rewrite the object\n"
"with its definition everywhere. Lean often unfolds terms automatically, but some tactics and definitions\n"
"are not unfolded automatically. The `unfold` tactic also helps make it easier to take the next steps.\n"
"\n"
"## Example:\n"
"\n"
"If you have a goal `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`, with `¬¨ P` (\\\"Not\\\" P) being defined as `P ‚Üí False`,\n"
"using `unfold Not` will change the goal to `(P ‚Üí Q) ‚Üí ((Q ‚Üí False) ‚Üí (P ‚Üí False))`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "## Summary\n"
"\n"
"`intros` acts very similar to the `intro` tactic, except it allows you to introduce many new\n"
"hypotheses/variables at once. `intros h1 h2 h3` essentially acts as `intro h1; intro h2; intro h3;`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `P ‚Üí Q ‚Üí (‚àÄ x : Nat, R ‚Üí (x = 5))`, `intros p q x r` will create hypotheses `p: P`,\n"
"`q: Q`, `r: R`, and a variable `x: Nat`, and change the goal to `x = 5`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "In this level, we will learn the `unfold` and `apply` tactics. Our goal is to prove `(P ‚Üí Q) ‚Üí (¬¨ Q ‚Üí ¬¨ P)`,\n"
"which looks very messy and difficult, but it can be slowly unfolded and broken down into simple steps.\n"
"\n"
"The first tactic we will need is `unfold`. You may notice the `¬¨` symbol appearing multiple times in\n"
"the goal. This symbol means \"Not\", so `¬¨P` means \"not P\", or that P is false. In Lean, this is\n"
"encoded as `P ‚Üí False`.\n"
"\n"
"### Unfold\n"
"The `unfold` tactic will unfold definitions. Think of it as a big `rw` tactic that rewrites something\n"
"with it's definition everywhere. In this level, `unfold Not` will replace all the `¬¨ P`s with `P ‚Üí False`.\n"
"\n"
"We know how to deal with statements of the form `P ‚Üí Q` in the goal, but what happens if we have them\n"
"as hypotheses? In this case, we will need the `apply` tactic.\n"
"\n"
"### Apply\n"
"The `apply` tactic applies a hypothesis of the form `P ‚Üí Q` to the goal. If your goal is `Q`, and\n"
"you have a hypothesis `h: P ‚Üí Q`, `apply h` will change the goal to `P`.\n"
"\n"
"### Combining hypotheses\n"
"Another way to use `h: P ‚Üí Q` hypotheses is that if you also have another hypothesis  `h2: P`,\n"
"`h h2` will be a proof of `Q`. So, if you have these two hypotheses, and your goal is `Q`, `exact h h2`\n"
"will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Try using `unfold Not` to unfold the definition of `¬¨`."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since there is a hypothesis also with a `¬¨` symbol, `unfold Not at *` will unfold\n"
"everywhere!"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, since you goal is of the form `P ‚Üí Q`, the `intro` tactic may help."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "You can still use the `intro` tactic because the goal is still of the form `P ‚Üí Q`"
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Now, try the `apply` tactic. Remember that if your goal is `Q`, you can use `apply h` when\n"
"h is a hypothesis or proof that `P ‚Üí Q`. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "Again, try the `apply` tactic to change the goal. You can also solve the level with one carefully worded\n"
"`exact` statement if you combine your hypotheses."
msgstr ""

#: Game.Levels.TutorialWorld.Level05
msgid "This theorem shows that a statement `P ‚Üí Q` implies its contrapositive `¬¨Q ‚Üí ¬¨P`. In fact, these\n"
"two statements are the same, and you can prove `(P ‚Üí Q) ‚Üî (¬¨ Q ‚Üí ¬¨ P)`\n"
"\n"
"Also, instead of writing intro three times, you can write `intros h1 h2 h3`, and that will be the\n"
"same as `intro h1; intro h2; intro h3`."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "The `cases'` and `exfalso` tactics"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases' h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `h : P ‚à® Q` is a hypothesis, then `cases' h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases' h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"\n"
"## Example\n"
"\n"
"If `h : ‚àÉ (a : ‚Ñù), a * a = 0` is a hypothesis, thatn `cases' h with a ha` will create a variable\n"
"`a : Nat` and a hypothesis `ha : a * a = 0`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "## Summary\n"
"\n"
"`exfalso` changes any goal to `False` this works because proving `False` is a contradiction and can\n"
"thus prove anything else. Mathematically, this means that for any proposition `P`, `False ‚Üí P`.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal`"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "This level introduces the `cases'` and `exfalso` tactics. The goal of this level is to prove `(P ‚àß ¬¨ P) ‚Üí Q`.\n"
"This proof is similar to a proof by contradiction. The first part of the implication, `P ‚àß ¬¨ P`, is\n"
"a contradiction, so it can prove any proposition `Q`.\n"
"\n"
"### Cases'\n"
"The `cases'` tactic is very important in Lean. It allows you to split any object or hypothesis into\n"
"cases. In this level, we will eventually have an and statement as a hypothesis. If we have `h: P ‚àß Q`,\n"
"`cases' h with hL hR` will create two hypotheses: `hL: P`, and `hR: Q`. If you have an object `x` that\n"
"can be split into cases, `cases' x with c1 c2` will split `x` into cases called `c1` and `c2`.\n"
"\n"
"### Exfalso\n"
"The `exfalso` tactic is also useful in this level. It simply changes the goal to `False`. This works\n"
"because if you can prove `False`, you have a contradiction, and can thus prove any statements. For\n"
"example, if you have a hypothesis `h: False`, and a goal `Q`, `exfalso; exact h` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You have two main options here. Note that you have a statement of the form `P ‚Üí Q`, so there\n"
"is a tactic we know that can simplify the goal. Also, we have a `¬¨` character, so unfolding that\n"
"could also be helpful"
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Since the `¬¨` symbol is in a hypothesis now, instead of the goal, in order to unfold it you\n"
"need to do `unfold Not at h`, where you replace `h` with the name of your hypothesis. `unfold Not\n"
"at *` will also unfold it everywhere."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "Now, use the `cases'` tactic to split up your and statement hypothesis."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "It would be nice if our goal was `False` here."
msgstr ""

#: Game.Levels.TutorialWorld.Level06
msgid "You now know most of the basics for working with logic in Lean! The remaining levels in the tutorial\n"
"world will move away from pure logic, but many of the tactics used already will still be essential."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "## Summary\n"
"The `linarith` tactic simplifies the goal by using the hypotheses. It works well on linear inequalities\n"
"and equalities. It works by looking for contradictions, although the actual algorithmic implementation\n"
"is very complicated.\n"
"\n"
"## Example\n"
"\n"
"If you have a bunch of hypotheses like h1 : a < b, h2 : b <= c, h3 : c = d and a goal of a < d,\n"
"then linarith will solve it. Linarith knows how to combine linear relations: it knows a ton of\n"
"results about how to put inequalities together and will close such goals."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "The `linarith` tactic aims to simplify the process of proofs. Specifically, it solves certain kinds\n"
"of linear equalities and inequalities. It attempts to solve or simplify the goal using the hypotheses\n"
"and certain properties of the numbers you are working with."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "In this level, simply trying `linarith` should solve the level."
msgstr ""

#: Game.Levels.TutorialWorld.Level07
msgid "Linarith is very useful to simplify goals involving linear terms."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "### Summary\n"
"\n"
"The `simp` tactic tries to simplify the goal, and will solve it if possible. It acts similar to the\n"
"`rw` tactic, although it is able to rewrite with many different statements many times in order to\n"
"simplify the goal. `simp` will try to use all the theorems available if not told explicitly what\n"
"theorems to use.\n"
"\n"
"Using `simp only [tactic1, tactic2, ...]` will simplify only using the theorems listed.\n"
"\n"
"### Example\n"
"\n"
"If your goal is something simple like `0 + 0 = 0`, `simp` will know enough about the natural numbers\n"
"to solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If your goal is `(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h`, which seems\n"
"complicated, but you only need to use associativity and commutativity of addition,\n"
"`simp only [add_assoc, add_left_comm, add_comm]` will solve the goal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "The `simp` tactic aims to simplify your goal. Often if a goal seems very complicated, or uses\n"
"definitions that need to be unfolded, the `simp` tactic will make progress.\n"
"\n"
"`simp` is not a flawless tool, and there are many simple statements it cannot prove, although when\n"
"used correctly, it can be very useful.\n"
"\n"
"In this level, your goal is to prove an equality about certain elements in a \"Group\". A group is a\n"
"mathematical object where elements in a group can be multiplied together in a way that \"makes sense\".\n"
"Examples of groups involve the real numbers, integers, invertible square matrices of a specific size,\n"
"and many more. `simp` knows many theorems about groups, and is able to simplify and solve most\n"
"simple statements about them.\n"
"\n"
"In this level, `a b c` are all elements of G, `1` is the multiplicative identity of G, and `a‚Åª¬π` is\n"
"the multiplicative inverse of `a`. You can see that both sides of the equation will cancel out to `b`,\n"
"but there is an easy way to prove that they are equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "Just typing `simp` will solve the goal"
msgstr ""

#: Game.Levels.TutorialWorld.Level08
msgid "`simp` will be very useful when solving simple equations in future worlds. You can always\n"
"read more about it by clicking on it on the right."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "The `use` tactic and your first theorem"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a ‚â§ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a ‚â§ b` by `use`ing the\n"
"number which is morally `b - a` (i.e. `use b - a`)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the `use` function is accurate:\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "le_iff_exists_add is a proof that `a ‚â§ b ‚Üî ‚àÉ (c : ‚Ñï), a = b + c`.\n"
"\n"
"The reason for the name is that two numbers are less than or equal to each other if and only if\n"
"there exists a number that you can add to the smaller one to make them equal."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "In this level, the goal is to prove `x ‚â§ 1 + x`. This requires understanding how to prove statements\n"
"about inequalities. We can define the `‚â§` symbol so that `a ‚â§ b` means `‚àÉ (c : ‚Ñï), b = a + c`. In\n"
"other words, a is less than or equal to b if and only if there exists a natural number c where\n"
"b = a + c. In this level, we have decided to use the natural numbers, although the statement is\n"
"clearly also true when working with real numbers. This is because the theorem \"le_iff_exists_add\"\n"
"does not work with the real numbers, so the proof would be slightly different.\n"
"\n"
"We have this statment as a theorem, \"le_iff_exists_add\".\n"
"\n"
"However, note that this theorem will rewrite the goal to have a `‚àÉ` symbol. In this case, we have to\n"
"find a number that satisfies a certain property. Once you find such a number, you can use the `use`\n"
"tactic.\n"
"\n"
"`use c` changes the goal from the form `‚àÉ x, Property(x)` to `Property(c)`. This allows you to solve\n"
"`‚àÉ` goals, but you need to first find a valid example, which may take some planing ahead."
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Try using the new theorem! Since it is a proof of `‚Üî`, the rewrite tactic should work!"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "What number should you use here to make the statement true?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "You now have a simple linear equation. What tactic can solve linear equations and prove\n"
"equalities?"
msgstr ""

#: Game.Levels.TutorialWorld.Level09
msgid "Now on to the last level in the tutorial world!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction' n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction' n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "'add_succ' is a proof that `n + Nat.succ m = Nat.succ (n + m)`.\n"
"\n"
"The reason for the name is that the theorem proves that adding the successor of a number is equal to\n"
"the successor of addind that number."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "The `induction'` tactic is a powerful tool to help you to prove statments involving natural numbers.\n"
"It splits a proof into two cases: a base case and an inductive step. The base case is the smallest\n"
"natural number you need to prove the proof for. The inductive step proves the theorem for all other\n"
"numbers. In the inductive step, you can assume the theorem holds for some value `d`, and must then\n"
"prove that it holds for `d + 1`, also written as `Nat.succ d`, the successor of `d`. Induction can\n"
"also be used to prove theorems about objects indexed my natural numbers, such as vectors whose\n"
"dimension can be described by a natural number.\n"
"\n"
"The syntax for the `induction'` tactic is `induction' n with d hd`. As long as `n` is an arbirtary\n"
"natural number in the proof, this will do induction on `n`, where `d` is the number you assume the\n"
"theorem holds for in the inductive step, and `hd` is the induction hypothesis you will get.\n"
"\n"
"This level also uses a new theorem: `add_succ`. `add_succ` is a proof that\n"
"`n + Nat.succ m = Nat.succ (n + m)`, for any `n, m : ‚Ñï`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "First, perform induction on `n`."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, for the base case, you need to prove a simple property of the naturals."
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "You are adding the successor of a number here, try to simplify this using the new theorem!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "Now, use the inductive hypothesis to finish the proof!"
msgstr ""

#: Game.Levels.TutorialWorld.Level10
msgid "## Summary\n"
"You have now finished Tutorial World! Now, you can move on to Vector Space world.\n"
"\n"
"The future worlds will be more challenging than this one, and will use less hints. However, if you're\n"
"stuck on how a tactic or theorem works, you can always read what they do on the right, or return to\n"
"Tutorial World for more review!\n"
"\n"
"Click \"Leave World\" to return to the main menu."
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Tutorial World"
msgstr ""

#: Game.Levels.TutorialWorld
msgid "Welcome to the tutorial world! This world is designed to indroduce you to Lean 4.\n"
"\n"
"In this world, we start with proving 'x=x', and then move on to solve basic logic problems and\n"
"simple theorems about the natural numbers.\n"
"\n"
"If you already know how to use Lean 4, you can skip this world, although we recommend playing through it.\n"
"\n"
"Click start to begin solving your first level!"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Vector space intro, zero scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "## Summary\n"
"The `symm` tactic stands for symmetry of equality. It shows that if we know `a = b`, then `b = a`.\n"
"\n"
"## Example\n"
"If your goal is `a = b`, `symm` will change the goal to `b = a`.\n"
"\n"
"## Example\n"
"If you have a hypothesis `h: a = b`, `symm at h` will change the hypothesis to `h: b = a`.\n"
"\n"
"## Example\n"
"If you have a theorem `add_dist: ‚àÄ a b c, (a + b) * c = a * c + b * c`, and a goal `2 * x + 5 * x = y`,\n"
"`rw[(add_dist 2 5 x).symm]` will change the goal to `(2 + 5) * x = y`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "## Vector Space Definition\n"
"\n"
"We begin by defining a vector space `V` over a field `K` as an abelian group with four key axioms:\n"
"\n"
"```\n"
"class VectorSpace (K V : Type) [Field K] [AddCommGroup V] extends Module K V where\n"
"  smul_add_explicit : ‚àÄ (a : K) (x y : V), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y := smul_add -- Distributivity over vector addition\n"
"  add_smul_explicit : ‚àÄ (a b : K) (x : V), (a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x := add_smul -- Distributivity over scalar addition\n"
"  mul_smul_explicit : ‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x) := mul_smul -- Associativity of `‚Ä¢` and `*`\n"
"  one_smul_explicit : ‚àÄ (x : V), (1 : K) ‚Ä¢ x = x := one_smul -- The multiplicitave identity acts as an identity\n"
"```\n"
"\n"
"This foundational structure will be used throughout all future levels. We are also using Mathlib's `Module`,\n"
"`Field`, and `AddCommGroup` definitions, which lets us use notation such as `-a` and `a‚Åª¬π`, and includes\n"
"many helpful theorems that we will not need to prove ourselves.\n"
"\n"
"Note that to write the `‚Ä¢` character, type\n"
"\"\\smul\".\n"
"\n"
"Also, note that there is some strange `inst‚Ä†` text in your objects. This simply means that your objects\n"
"are instances of certain classes, for example that K V is a vector space.\n"
"\n"
"## Goal for this level\n"
"\n"
"In this level, you'll prove that multiplying a vector by the zero scalar (`0 : K`) results in the\n"
"zero vector (`0 : V`). This is going to be a slightly involved proof, so it is important to get an\n"
"understanding of the proof before beginning to write it.\n"
"\n"
"The first step of a normal proof would be writing `0 ‚Ä¢ w` as `(0 + 0) ‚Ä¢ w`, then using distributivity\n"
"to get it as `0 ‚Ä¢ w + 0 ‚Ä¢ w`. Lastly, cancelling out a `0 ‚Ä¢ w` on each side gets `0 = 0 ‚Ä¢ w`.\n"
"\n"
"However, this proof relies on our assumptions and constructs the goal from them. This can be done in\n"
"Lean, however, it requires using the `have` tactic, and is unnescessarily complex. In Lean, proofs are\n"
"often done backwards, working from the goal and creating the hypotheses.\n"
"\n"
"Doing the proof backwards thus must first involve adding `0 ‚Ä¢ w` to both sides of the goal, undoing\n"
"distributivity, then cancelling out some zeros.\n"
"\n"
"### add_right_cancel\n"
"\n"
"To use cancellation of addition, we need a new theorem, `add_right_cancel`. This theorem is a proof\n"
"that `a + b = c + b ‚Üí a = c`. Since your goal is of the form `a = c`, `apply add_right_cancel` will\n"
"change the goal to `a + ?b = c + ?b`. However, you want to be able to write the value of `?b`, but\n"
"in this case, Lean doesn't know what value you want to add. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`, replacing the question marks with whatever you\n"
"want to add.\n"
"\n"
"### zero_add\n"
"\n"
"We also need to know some basic theorems about addition. For both the scalars and vectors, adding any\n"
"vector to `0` will result in that vector. Simply `rw [zero_add]` will show this.\n"
"\n"
"### symm\n"
"\n"
"You will also need the `symm` tactic. `symm` stands for symmetry of equality, and it can be used to\n"
"change goals of the form `a = b` to `b = a`. `symm at h` will also change a hypothesis `h: a = b` to\n"
"`h: b = a`. However, neither of these uses are needed in this level. You may\n"
"notice that if `h: a = b` is a hypothesis, rw[h] will rewrite all `a`s to `b`s. What if you want to\n"
"rewrite all `b`s to `a`s, you can instead do `rw[h.symm]`.\n"
"\n"
"Also note that when the theorem has a `‚àÄ` symbol, as in `‚àÄ a b : S, a + b = b + a`, you need to\n"
"specify what `a` and `b` you mean to use before using `.symm`. For example, you would have to write\n"
"`rw[(h 2 3).symm]`.\n"
"\n"
"One last hint is that when writing `0`, you often want to specify which zero you are talking about.\n"
"We know that the natural numbers, for example, has a `0`, but so do the Field K and the Abelian Group\n"
"V, and those `0`s are different. To specify which `0` you are talking about, write `(0 : K)` or `(0 : V)`.\n"
"\n"
"### Note on simp and linarith\n"
"\n"
"In this world, we are primarilly proving simple statements about vector spaces. This is exactly what\n"
"the `simp` and `linarith` tactics are meant to do. In fact, the `simp` tactic alone would be able to\n"
"solve the first three levels of this world. Because of this, you will not be able to use those tactics\n"
"in this world."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "A vector space is a space over a field K with an abelian group V. It has four main properties:\n"
"- Distributivity over vector addition,\n"
"- Distributivity over scalar addition,\n"
"- Associativity of scalar multiplication,\n"
"- Identity scalar acting as identity.\n"
"\n"
"These properties can be found in the theorems tab as \"smul_add\", \"add_smul\", \"mul_smul\", and \"one_smul\"."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "This is a proof that `0 ‚Ä¢ w = 0`, or that scaling any vector by `0` gives the zero vector.\n"
"\n"
"It is called \"zero_smul_v\", since you perform scalar multiplication by zero. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`add_right_cancel` is a proof that `a + b = c + b ‚Üí a = c`. You can tell Lean what to add to the\n"
"equation by `apply add_right_cancel (b := ????)`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`smul_add` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a : K) (x y : V), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y`. It can be considered as right distributivity\n"
"of scalar multiplication"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`add_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a + b) ‚Ä¢ x = a ‚Ä¢ x + b ‚Ä¢ x`. It can be considered as left distributivity\n"
"of scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)\n"
"`mul_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (a b : K) (x : V), (a * b) ‚Ä¢ x = a ‚Ä¢ (b ‚Ä¢ x)`. It can be considered as associativity of scalar\n"
"multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`one_smul` is one of the axioms of a vector space. It is a proof that if we know `vs : VectorSpace K V`,\n"
"then `‚àÄ (x : V), (1 : K) ‚Ä¢ x = x`. It can be thought of as `1` being a multiplicative identity not\n"
"only in `K`, but also through scalar multiplication in `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`symm` is a proof that `a = b` if and only if `b = a`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "`zero_add` is a proof that `0 + x = x`. This holds whether `x` is in `K` or `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "<<<<<<< HEAD\n"
"=======\n"
"`zero_add` is a proof that `0 + x = x`. This holds whether `x` is in `K` or `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid ">>>>>>> 90d4b8f (Updated to module definition of subspace, finished proofs of world 2, started world 2 level 1)\n"
"`add_zero` is a proof that `x + 0 = x`. This holds whether `x` is in `K` or `V`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "In any vector space V over K, the scalar 0 multiplied by any vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Remember, we are trying to prove this backwards. The last step in the normal proof was to\n"
"cancel out 0 ‚Ä¢ w from both sides, so what should the first step of the backwards proof be?"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try `apply add_right_cancel (b := (0 : K) ‚Ä¢ w)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Now, there is a theorem we have from the vector space definition that can change the left\n"
"side of the equation. Think about the second to last step in the normal proof. You may also need to\n"
"use `.symm` here."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try `rw[(add_smul (0 : K) (0 : K) w).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Now, we just have to cancel out zeros."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try rw[zero_add]"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "Try rw[zero_add]"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level01
msgid "You have now proven your first theorem about vector spaces! One note: if you want to use\n"
"one of the theorems you prove in one level in another level, the syntax will often be\n"
"`theorem_name K V theorem_args`. This lets Lean know what vector space you are working with."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Multiplying by the zero vector"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "We just proved that multiplying by the zero scalar gives the zero vector. Now, we will\n"
"show that multiplying by the zero vector also gives the zero vector.\n"
"\n"
"The proof is very similar to the last level, and requires no new tactics.\n"
"\n"
"Again, first think out the proof yourself (pencil and paper may help), then reverse the proof and\n"
"write it in lean. You can also look at the previous level for inspiration and syntax help."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "This is a proof that `a ‚Ä¢ 0 = 0`, or that scaling the zero vector by any scalar gives the zero vector.\n"
"\n"
"It is called \"smul_zero_v\", since you perform scalar multiplication by the zero vector. The \"v\" means that it is\n"
"scalar multiplication of a vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "In any vector space V over K, any scalar a multiplied by the zero vector gives the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `apply add_right_cancel (b := a ‚Ä¢ (0 : V))`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[(smul_add a (0 : V) (0 : V)).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level02
msgid "Try `rw[zero_add]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Scaling by -1"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "This is a proof that `-1 ‚Ä¢ v = -v`, that multiplying by the -1 scalar gives the inverse vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "We now understand scaling by `0` very well. We also have an axiom that scaling by `1`\n"
"acts as the identity. The next step is to see what scaling by `-1` does. Intuitively, it should\n"
"cancel out the vector scaled by `1`, so it should be the additive inverse of the vector.\n"
"\n"
"The goal of the level is to prove this.\n"
"\n"
"A few hints that could help:\n"
"The defining property of `-v` is that `-v + v = 0`. The `simp` tactic can use this. Try to use this\n"
"in your proof.\n"
"You can also use the theorems proven in previous levels.\n"
"\n"
"### Difficulty with `one_smul`\n"
"You may eventually try to rewrite a vector `v` as `1 ‚Ä¢ v` in this level. However, trying\n"
"`rw[(one_smul v).symm]` may run into errors. This is because `one_smul v` only takes an element of `V`\n"
"as input, so Lean doesn't know which field \"K\" to use to get the \"1\" from. To fix this, try\n"
"`one_smul K v` to tell Lean which \"K\" you are using.\n"
"\n"
"### `neg_add_self` theorem\n"
"In order to work with negatives, we also have the theorem `neg_add_self`. This is a proof that `-x + x = 0`.\n"
"Similarly to `zero_add`, this theorem works in both K and V. This allows you to cancel out negatives."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "`neg_add_self` is a proof that \"-x + x = 0. This holds whether x is in K or V."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "`neg_add_self` is a proof that \"-x + x = 0. This holds whether x is in K or V."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "In any vector space V over K, multiplying a vector by -1 gives its additive inverse."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "A good first step is cancelling out the `-v` term on the right."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `apply add_right_cancel (b := v)`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Remember the `nth_rw m [theorem]` tactic to only rewrite the mth instance."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `nth_rw 2 [(one_smul (K := K) v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[(add_smul (-1 : K) (1 : K) v).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[neg_add_self]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `rw[neg_add_self]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "This looks like something we've done before. Either the `rw` or `exact` tactics should solve the goal"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "Try `exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level03
msgid "We now have many theorems relating to vector spaces! In the next levels, we will introduce\n"
"the idea of a \"subspace\"."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Zero must belong"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now that we understand more about vector spaces, let's define what a subspace is.\n"
"Intuitively, a subspace is a subset of a vector space that can be considered as a vector space itself.\n"
"We define this as a subset `W : Set V` that is nonempty, is closed under addition, and is closed under scalar multiplication.\n"
"\n"
"### The `obtain` tactic\n"
"A new tactic will help us solve problems with subspaces. While not necessary, and this tactic can\n"
"even be completely replaced by the `cases'` tactic, it will simplify your proofs greatly. The `obtain`\n"
"tactic essentially acts as repeating `cases'`. In this level, it has two main uses. First, if `hw : isSubspace W`\n"
"is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition into the three parts,\n"
"labeled h1, h2, and h3. The other important use for `obtain` is if you have a hypothesis `hW : W.Nonempty`,\n"
"then `obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`. The \"‚ü®\"\n"
"character is written with \"\\langle\", and the \"‚ü©\" character is written with \"\\rangle\".\n"
"\n"
"### Subspace contains zero\n"
"One of the basic properties of a subspace is that it must be nonempty. In fact, every subspace must\n"
"contain the zero vector. This is because for any vector in a subspace, you can multiply it by the zero\n"
"scalar while still remaining in the subspace, which wil result in the zero vector. In this level, we\n"
"formally prove this result."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "A subspace is a subset of a vector space that acts similarly to a vector space itself. It has three\n"
"main properties:\n"
"- Nonempty: a subspace cannot be empty\n"
"- Closure under addition: adding any two elements of a subspace should remain in that subspace\n"
"- Closure under scalar multiplication: scaling any vector in a subspace should remanin in that subspace\n"
"\n"
"Subspaces are formalized by having the `isSubspace` proposition, which simply combines the three\n"
"properties into one proposition."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "## Summary\n"
"The `obtain` tactic works very similar to repeating the `cases'` tactic. The `obtain` tactic splits a\n"
"statement into cases, and allows you to name each case. Instead of splitting into two cases, like the\n"
"`cases'` tactic, `obtain` can split into as many cases as necessary. The syntax looks like\n"
"`obtain ‚ü®h1, h2, h3‚ü© := h`.\n"
"\n"
"## Example\n"
"If `hw : isSubspace W` is a hypothesis, then `obtain ‚ü®h1, h2, h3‚ü© := hW` will split the definition\n"
"into three parts, labeled h1, h2, and h3.\n"
"\n"
"## Example\n"
"If you have a hypothesis `hW : W.Nonempty`, where `W : Set V` is a subset of `V`, then\n"
"`obtain ‚ü®w, hw‚ü© := hW` will give you a `w : V`, and a hypothesis `hw : w ‚àà W`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "This is a proof that any subspace contains the zero vector."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try to expand out your hypotheses using `obtain`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Again, you can use `obtain` to simplify a hypothesis."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `obtain ‚ü®w, hw‚ü© := ¬´{h1}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "We know that `0 ‚Ä¢ ¬´{w}¬ª ‚àà W`. If this was our goal, the level would be easy to solve. Also,\n"
"remember that if you have to use a theorem you have proven in a previous level, you have to write\n"
"`theorem_name K V theorem_args` to show Lean that K V is a vector space."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `rw [(zero_smul_v K V w).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Now, apply the fact that subspaces are closed under scalar multiplication."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `apply ¬´{h3}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level04
msgid "Try `exact ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Negatives in Subspace"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "The last theorem we will prove in Vector Space World is that subspaces contain the additive inverses\n"
"of each of their elements. The proof is very similar to the previous level. You can try to solve it\n"
"completely on your own, and if you get stuck, you can always press the \"Show more help!\" button to\n"
"get the next step."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "This is a proof that if a subspace contains a vector `x`, it also contains `-x`."
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `obtain ‚ü®h1, h2, h3‚ü© := hW`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `intros x hx`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `rw [(neg_one_smul_v K V ¬´{x}¬ª).symm]`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `apply ¬´{h3}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "Try `exact ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.VectorSpaceWorld.Level05
msgid "You have now completed Vector Space World! The theorems proven here will be very helpful\n"
"in future worlds. You can now move on to World 2: Linear Independence and Span World!"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Vector Space World"
msgstr ""

#: Game.Levels.VectorSpaceWorld
msgid "Welcome to Vector Space World! In this world, you'll build up the basic theory of vector spaces\n"
"through formal proofs in Lean."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Linear Combinations"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "The first level of this world will introduce the definition of a linear combination. Let's\n"
"say we want to express that some vector `x` is a linear combination of some set `S ‚äÜ V`. This means\n"
"that there is some number of elements in `S`, that after some scalar multiplication, sums to `x`. We can\n"
"call this set of elements summing to `x` `s`, where `s : Finset V`, and `‚Üës ‚äÜ S`. We are using `Finset`\n"
"here, which means that `s` is a finite subset of V. This is because we can only sum in a way that makes\n"
"sense over a finite set. If `s` was infinite, there could be multiple ways of summing it to get different\n"
"answers, or a sum might not even exist. We also need to multiply every element of `s` by a scalar before\n"
"summing, whether that scalar be `1`, `0`, or anything else. We can represent this by a function `f : V ‚Üí K`,\n"
"where each element of `s` gets mapped to the scalar we multiply by. Now, we are able to understand the\n"
"definition of linear combinations:\n"
"\n"
"```\n"
"def is_linear_combination (S : Set V) (x : V) : Prop :=\n"
"  ‚àÉ (s : Finset V) (f : V ‚Üí K), (‚Üës ‚äÜ S) ‚àß (x = Finset.sum s (fun v => f v ‚Ä¢ v))\n"
"```\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if `v ‚àà S`, then `v` is a linear combination of `s`. This can\n"
"be done simply by summing over the set `{v}`, with only multiplying by the scalar 1.\n"
"\n"
"### Defining functions\n"
"In this level, we need to use the `use` tactic to specify a function `f`. A very versatile way of doing\n"
"this is with the `fun` keyword. This allows you to wrtie the function, and for Lean to accept it as a function.\n"
"For example, to write `f(x) = x¬≤`, we can say `fun x => x * x`.\n"
"\n"
"### The return of the `simp` tactic\n"
"Since the levels in this world will become more difficult than in the last world, you are again allowed\n"
"to use the `simp` tactic. It is able to solve most simple equalities with vectors, and helps greatly\n"
"when trying to simplify properties of sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "`is_linear_combination` is how we define a vector `x` to be a linear combination of some set `S ‚äÜ V`.\n"
"To say this, we write `is_linear_combination K V S x`. It is defined by the existance of some set `s ‚äÜ S`,\n"
"and a function `f : V ‚Üí K`, such that `x` is the sum over `s` of `f(v) ‚Ä¢ v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "`Finset.sum` is how we difine summing over a set. It uses Mathlib's `Finset` Type, which means that we\n"
"can only sum over arbitrary finite sets. The syntax is as follows: With a additive group or field `K`, some Type `T`,\n"
"some `s : Finset T`, and some `f : T ‚Üí K`, `Finset.sum s (fun x => f x)` sums `f x` over all `x ‚àà s`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "`linear_combination_of_mem` is a proof that if `v ‚àà S` then `is_linear_combination K V S v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "If `v ‚àà S`, then `v` is a linear combination of `S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "It is generally helpful to unfold definitions you are unfamiliar with"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Try `unfold is_linear_combination`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Now, you have to specify what set you are summing over"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Try `use {v}`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Now, you have to specify the function you are using to map vectors to the scalars they will be multiplied by"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Try `use (fun x => 1)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "This is an and statement, so you could use the `constructor` tactic and work from there. Instead, try `simp` and see what happens"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "Try `exact hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level01
msgid "You have completed your first proof in Linear Independence and Span World!"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Introducing Span"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "In this level, we will introduce the span of a set of vectors. The span of a set of vectors is simply\n"
"all the vectors that can be written as a linear combination of that set. In Lean, we define it as such:\n"
"\n"
"```\n"
"def span (S : Set V) : Set V :=\n"
"  { x : V | is_linear_combination K V S x }\n"
"```\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if a vector `v ‚àà S`, then `v` is in the span of `S`. This feels\n"
"very similar to the previous level, so you can use the theorem proved in the previous level in this one."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "`mem_span_of_mem` is a proof that if a vector `v ‚àà S`, then `v ‚àà span K V S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "The span of a set of vectors `S`, denoted `span K V S` is the set of all vectors that are a linear\n"
"combination of `S`. It is represented in Lean as\n"
"\n"
"``` { x : V | is_linear_combination K V S x } ```"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "If `v ‚àà S`, then `v ‚àà span K V S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Once again, we have a definition we are unfamiliar with in the goal. Try to change it to terms\n"
"we are familiar with"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `unfold span`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "The `simp` tactic is very helpful when dealing with sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "This seems familiar"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "Try 'exact linear_combination_of_mem K V hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level02
msgid "You could have actually solved this level with simply an `exact linear_combination_of_mem K V hv`.\n"
"This is because the way set-builder notation is defined in lean is that `x ‚àà { x : V | is_linear_combination K V S x }`\n"
"is the same as saying `is_linear_combination K V S x`. The `simp` tactic only directly shows you this."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Monotonicity of Span"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "### The Goal\n"
"In this level, you will prove that the span of a set of vectors is monotonic. That is, that if `A ‚äÜ B`,\n"
"then `span K V A ‚äÜ span K V B`. To understand why this is true, think about any arbitrary vector `x ‚àà span K V A`.\n"
"`x` must be a linear combination of vectors of `A`, and since all those vectors are in `A`, they must\n"
"also be in `B`, so `x` is a linear combination of vectors in `B`, and must be in `span K V B`.\n"
"\n"
"### `subset_trans`\n"
"To solve this level, we need a theorem `subset_trans`. This theorem shows that subsets are transitive,\n"
"so if you have `h1 : A ‚äÜ B` and `h2 : B ‚äÜ C`, then `subset_trans h1 h2` is a proof that `A ‚äÜ C`. This can be proven quite easily, but since we have\n"
"a theorem already proving it, why not use it?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "`subset_trans` is a proof that subsets are transitive. The syntax is that if you have `h1 : A ‚äÜ B`\n"
"and `h2 : B ‚äÜ C`, then `subset_trans h1 h2` is a proof that `A ‚äÜ C`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "`span_mono` is a proof that the span of sets is monotonic. Simply, this means that if you have `h : A ‚äÜ B`,\n"
"then `span_mono K V h` is a proof that `span K V A ‚äÜ span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "The span of sets is monotonic. Simply, this means that if you have `h : A ‚äÜ B`,\n"
"then `span_mono K V h` is a proof that `span K V A ‚äÜ span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "First, I would take an arbitrary `x`, then unfold and simplify our goals."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `intro x hxA`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `simp at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Now, what information can we get out of ¬´{hxA}¬ª?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `obtain ‚ü®s, hsA, f, h1, h2‚ü© := ¬´{hxA}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "What set should we be summing over?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `use ¬´{s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `exact subset_trans ¬´{hsA}¬ª ¬´{hAB}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "What function should we be using?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "Try `use f`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level03
msgid "The idea of unfolding all the definitions and then using `simp at *` is very helpful. I\n"
"would recommend using this sequence of tactics at the start of most levels.\n"
"\n"
"Also, note that `use f` closed the goal. This is because the `use` tactic attempts `rfl` after it\n"
"executes, similarly to `rw`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Linear Independence"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "This level will introduce linear independence of a set of vectors. A set `S` of vectors is linearly\n"
"independent if no vector in `S` can be written as a linear combination of the others. Equivalently,\n"
"we can say that `S` is linearly independent if any combination of vectors in `S` summing to `0` must\n"
"be all `0`s. In Lean, it is written as:\n"
"\n"
"```\n"
"def linear_independent_v (S : Set V) : Prop :=\n"
"‚àÄ (s : Finset V) (f : V ‚Üí K),\n"
"(‚Üës ‚äÜ S) ‚Üí (Finset.sum s (fun v ‚Ü¶ f v ‚Ä¢ v) = 0) ‚Üí (‚àÄ v ‚àà s, f v = 0)\n"
"```\n"
"\n"
"Note that we use the same idea as in linear combinations, where we have a Finset `s`, a function\n"
"mapping vectors to the scalars that multiply those vectors, and use `Finset.sum`.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that the empty set is linearly independent. This makes sense,\n"
"because there are no vectors in the empty set that can be scaled be a non-zero factor."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "This is a proof that the empty set is linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "`linear_independent_v` means that a set of vectors is linearly independent. To say a set `S : Set V`\n"
"is linearly independent, we write `linear_independent_v K V S`. This is defined that any finite set of scalar\n"
"multiples of vectors in `S` that sum to `0` must all be `0`. It is written in Lean as\n"
"\n"
"```\n"
"def linear_independent_v (S : Set V) : Prop :=\n"
"‚àÄ (s : Finset V) (f : V ‚Üí K),\n"
"(‚Üës ‚äÜ S) ‚Üí (Finset.sum s (fun v ‚Ü¶ f v ‚Ä¢ v) = 0) ‚Üí (‚àÄ v ‚àà s, f v = 0)\n"
"```\n"
"\n"
"Note that we use `Finset` here, which means that even though `S` can be infinite, `s` must be finite."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "The empty set is linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `unfold linear_independent_v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Here, we have many ‚àÄ and ‚Üí statements in the goal. Try to move these variables to the hypotheses"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `intros s f hs sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "We now have a hypothesis `¬´{hv}¬ª: v ‚àà ¬´{_s}¬ª` and `¬´{hs}¬ª : `‚Üë¬´{_s}¬ª ‚äÜ ‚àÖ`. This may be a contradiction,\n"
"so maybe we can chang eour goal to `False` and prove that"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "If you can figure out a way to get a proof of the form `¬´{v}¬ª ‚àà ‚àÖ`, that statement is equivalent\n"
"to `False`, so an `exact` statement could work. (Actually, `exact?` should solve the goal)"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "Try `exact hs hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level04
msgid "We won't prove it in this game (although it isn't too difficult), but any set containing\n"
"a single vector is also linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Linear Independence of Subsets"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "### The Goal\n"
"In this level, we will prove that subsets of linearly independent sets are also linearly independent.\n"
"This is because if any set of nonzero vectors in the smaller set were to sum to zero, then the same set\n"
"of vectors would be in the larger set, and also must sum to zero.\n"
"\n"
"### The `have` tactic\n"
"One very powerful tactic that you have not learned yet is the `have` tactic. This tactic allows you\n"
"to create your own hypotheses, as long as you can prove that they are correct. This allows you to take\n"
"more of a \"forward reasoning\" approach to Lean proofs, as you can create new hypotheses from your old\n"
"ones, slowly changing your hypotheses to the goal, instead of changing your goal to the hypotheses.\n"
"The syntax for a `have` statement is `have h : 0 ‚Ä¢ v = 0 := zero_smul_v v`. The `h` is the name of your\n"
"new hypothesis, `0 ‚Ä¢ v = 0` is the statement of the hypothesis, and `zero_smul_v v` is the proof of the\n"
"new hypothesis. You can read more about the tactic on the right side of the screen."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "## Summary\n"
"`have` allows you to create your own statements. It allows you to prove hypotheses which you can then\n"
"use to prove the goal.\n"
"\n"
"The syntax for `have` is `have h : Hypothesis := proof` to create a hypothesis `h : Hypothesis` where\n"
"`proof` is a proof of the hypothesis\n"
"\n"
"## `by`\n"
"`by` allows you to write muli-line proofs. When your have statement is a lemma that will take multiple\n"
"steps to prove, replacing your proof with `by` will add a subgoal to prove your hypothesis. All the\n"
"lines proving this hypothesis will need to be indented.\n"
"\n"
"Using `by` can also only be done in editor mode, which can be accessed by clicking the \"<\\>\" button in the\n"
"top right.\n"
"\n"
"## Example\n"
"If you want to have a hypothesis `h : 0 ‚Ä¢ v = 0`, then `have h : 0 ‚Ä¢ v = 0 := zero_smul_v v` will create\n"
"that hypothesis\n"
"\n"
"## Example\n"
"If you want to prove a lemma `simple_lemma : ‚àÄ (a b c n : ‚Ñï+), n > 2 ‚Üí a ^ n + b ^ n ‚â† c ^ n`, then\n"
"`have simple_lemma : ‚àÄ (a b c n : ‚Ñï+), n > 2 ‚Üí a ^ n + b ^ n ‚â† c ^ n := by` will change the goal to\n"
"proving your lemma, and once you prove it, you can then use the lemma."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "`subset_linear_independent` is a proof that if `A` is a linearly independent set, and we have `B ‚äÜ A`,\n"
"then `B` is also linearly independent. The syntax is as follows: if `hBsubA : B ‚äÜ A` and `hA : linear_independent_v K V A`\n"
"are hypotheses, then `subset_linear_independent hBsubA hA` is a proof that `linear_independent_v K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "If `A` is a linearly independent set, and we have `B ‚äÜ A`, then `B` is also linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `unfold linear_independent_v at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `intros s f hsB sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Look at hA. When all the assumptions are met, we get `f v = 0`, which is our goal. This means\n"
"that if we are able to get all of the assumptions as hypotheses, we can solve with an exact statement.\n"
"However, we still don't have a hypothesis that `‚Üës ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `have hsA : ‚Üës ‚äÜ A := subset_trans hsB hBsubA`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Now, the level can be solved with a (slightly long) `exact` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level05
msgid "Try `exact hA s f hsA sum_zero v hv`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Supersets Span the Whole Space"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Now that we know some properties of subsets, we can work on a property of supersets. This level is a\n"
"proof that if `A` spans the whole space, then any `B ‚äá A` also spans the whole space\n"
"\n"
"### The Goal\n"
"We have three sets, and three hypotheses. We have sets `A` and `B`, which are the set and superset we\n"
"are working with. We also have the set `T`, which is the entire space `V`. The reason we are using `T`\n"
"instead of `V` is that `T` is an object of the type `Set V`, which is the same type as `span K V A` or\n"
"`span K V B`. We can't compare these spans with `V`, but we can compare them with `T`. This also means\n"
"we need a hypothesis  (hT : ‚àÄ (x : V), x ‚àà T), which means that any element of `V` is also in `T`.\n"
"The other two hypotheses simply state that `B` is a superset of `A`, and that the span of `A` is `T`.\n"
"The goal is to prove that the span of `B` is also `T`.\n"
"\n"
"### `Set.eq_of_subset_of_subset`\n"
"When working with sets, a very useful theorem is `Set.eq_of_subset_of_subset`. This theorem shows that\n"
"two sets are equal if and only if they are subsets of each other. So, if you have a goal of the form\n"
"`A = B`, `apply Set.eq_of_subset_of_subset` will change the goal into two goals: `A ‚äÜ B`, and `B ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "`superset_span_full` is a proof that if a set `A` spans the whole space `V`, then any superset of `A`\n"
"also spans `V`. The syntax requires a set `T : Set V` with the property `hT: ‚àÄ (x : V), x ‚àà T`, so that\n"
"`T` is a subset that is actually the entire space. With other hypotheses `hA : T = span K V A`, and\n"
"`hAsubB : A ‚äÜ B`, then `superset_span_full` is a proof that `T = span K V B`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "`Set.eq_of_subset_of_subset` is a proof that `A = B` if and only if `A ‚äÜ B` and `B ‚äÜ A`. If you have\n"
"a goal of the form `A = B`, `apply Set.eq_of_subset_of_subset` will change the goal into two goals:\n"
"`A ‚äÜ B`, and `B ‚äÜ A`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "If a set $A$ spans the whole space $V$, then any superset of $A$ also spans $V`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `apply Set.eq_of_subset_of_subset`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `rw [hA]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `exact span_mono K V hAsubB`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `intros x ssg`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "Try `exact hT ¬´{x}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level06
msgid "The next three levels in this world will be much more difficult. The next level can be\n"
"thought of as a \"boss level\", and the last two levels can be extra optional challenges. Try to plan\n"
"out your proofs before writing them."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Uniqueness of linear combinations"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "This is the \"boss level\" of the Linear Independence and Span World. This level is a\n"
"proof that in a linearly independent set, linear combinations are unique. There are also a few new tactics\n"
"and multiple new theorems you should use.\n"
"\n"
"### The Goal\n"
"In this level, we have 5 objects and 6 hypotheses about those objects. We have the set `S : Set V`,\n"
"which is the linearly independent set we are working with. We also have `s` and `f`, which are the set\n"
"and function we are summing over to get the first linear combination, and `t` and `g` are the second\n"
"linear combination. We have `hs : linear_independent_v K V S`, which states that `S` is linearly independent,\n"
"`hs : ‚Üës ‚äÜ S` and `ht : ‚Üët ‚äÜ S`, which state that `s` and `t` are both in `S`, so are valid linear\n"
"combinations of `S`. We know `hf0 : ‚àÄ v ‚àâ s, f v = 0` and a similar `hg0`, which state that both functions\n"
"are zero outside of their domain. This helps us prove `f = g`, since otherwise we wouldn't know what\n"
"the values of `f` and `g` would be outside of `s` and `t`. Lastly, we have `heq : Finset.sum s (fun v => f v ‚Ä¢ v) = Finset.sum t (fun v => g v ‚Ä¢ v)`,\n"
"which shows that the two linear combinations are equal. We then must pove that `f = g`\n"
"\n"
"### The `specialize` tactic\n"
"The `specialize` tactic can be thought of as the opposite of `use`. While `use` helps specify a value\n"
"for a `‚àÉ` in the goal, `specialize` specifies a value for a `‚àÄ` in a hypothesis. For example, if you\n"
"have a hypothesis `h : ‚àÄ v : V, v ‚Ä¢ 1 = v`, and you have a vector `x : V`, then `specialize h x` will\n"
"change `h` to `h : x ‚Ä¢ 1 = x`. `specialize` also works if `h` is an implication. If `h1 : P ‚Üí Q` is a\n"
"hypothesis, and `h2 : P` is a proof of `P`, then `specialize h1 h2` will change `h2` to `h2 : Q`.\n"
"\n"
"### The `by_cases` tactic\n"
"The `by_cases` tactic helps you prove something by cases. If you want to prove a statement about vectors\n"
"in `V`, but you want to split into cases where `v = 0` or `v ‚â† 0`, `by_cases hv : v = 0` will split the\n"
"goal into two subgoals: one where you have a hypothesis `hv : v = 0`, and another where you have a hpyothesis\n"
"`hv : v ‚â† 0`.\n"
"\n"
"### The `funext` tactic\n"
"The `funext` tactic lets you prove statements about functions. It works similarly to the `intro` tactic,\n"
"where you introduce an arbitrary object, but instead of introducing from a `‚àÄ` statment, it works if\n"
"you have a goal of the form `f = g`, where `funext x` will chang ethe goal to the form `f x = g x`, and\n"
"give you an arbitrary `x` in the domain of `f` and `g`.\n"
"\n"
"### New theorems\n"
"This level requires multiple new theorems, particularly ones about Finsets and sums. There are two theorems\n"
"about vector spaces that can be proven quite easily, but they are still nice to have without needing\n"
"to prove them first. Instead of explaining them all here, you can look at them on the right side of\n"
"the screen. The new theorems are: `coe_union`, `union_subset`, `sub_smul`, 'sum_add_distrib', 'sum_sub_distrib',\n"
"`subset_union_left`, `subset_union_right`, `sum_subset`, `sub_eq_zero`, and `not_mem_union`.\n"
"If you need more theorems, you can either prove them in lemmas, or if you want, you can go to the world\n"
"select menu and turn \"Rules\" to \"none\", which should allow you to use any tactic or theorem in Lean.\n"
"\n"
"### Proof overview\n"
"If you look at the hypotheses you have, the most important ones are that S is linearly independent and\n"
"that the two sums are equal. When you have a statement that a set is linearly independent, it is often\n"
"very helpful to try to find the correct set and function to sum over, then try to satisfy the assumptions\n"
"to prove that the function must be zero. Since the goal is to prove that `f = g`, maybe try to prove\n"
"instead that `f - g = 0`, so you can try proving the assumptions in `hS` with the function `f - g`. You\n"
"also need to pick the correct set to be summing over. Since this set must contain both `s` and `t`, you\n"
"can use `s ‚à™ t`. Also, note that this will then only prove that `f = g` on the set `s ‚à™ t`, so you may\n"
"need to use `by_cases` to prove it outside `s ‚à™ t`.\n"
"\n"
"### Note on hints\n"
"With the use of `have` statements, you may have multiple goals at the same time. While this is not a\n"
"problem when writing the proof, the hint system may get confused. Starting to type where you\n"
"intend to write your next tactic will help clear up what goal you are working on, so it will help the hint\n"
"system. However, in general, try to follow your intuition without blindly following the hints."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "## Summary\n"
"The `by_cases` tactic is able to create a new hypothesis, and split the goal into two cases: one where\n"
"the hypothesis is true, and one where the hypothesis is false.\n"
"\n"
"In general, if you write `by_cases h : P`, you will create one goal with a hypothesis `h : P`, and another\n"
"with a hypothesis `h : ¬¨P`.\n"
"\n"
"## Example\n"
"If you have some vector `v : V`, and some set `s : Set V`, you can solve the proof by cases of whether\n"
"v is in s by writing `by_cases h : v ‚àà s`, which will give you two goals, one with the hypothesis `h : v ‚àà s`,\n"
"and one with the hypothesis `h : v ‚àâ s`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "## Summary\n"
"The `funext` tactic is very helpful when dealing with functions. It uses the idea that for two functions\n"
"`f : A ‚Üí B` and `g : A ‚Üí B`, `f = g` if and only if `f x = g x` for all `x ‚àà A`. This means that if you\n"
"have a goal `f = g`, where both functions have domain `A`, `funext x` will create an arbitrary `x : A`,\n"
"and change the goal to `f x = g x`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "## Summary\n"
"The `specialize` tactic can be thought of as the opposite of `use`. While `use` helps specify a value\n"
"for a `‚àÉ` in the goal, `specialize` specifies a value for a `‚àÄ` in a hypothesis. If you have a hypothesis\n"
"`h`, `specialize h x1 x2 x3` will specify the values in `h` as `x1`, `x2`, and `x3`.\n"
"\n"
"## Example\n"
"If you have a hypothesis `h : ‚àÄ x : V, f x = 0`, and some `v : V`, then `specialize h v` will\n"
"change the hypothesis to `h : f v = 0`\n"
"\n"
"## Example\n"
"If you have a hypothesis `h : x ‚àà s ‚Üí f x = 0`, and another hypothesis `h2 : x ‚àà s`, then `specialize h h2`\n"
"will change h to `h : f x = 0`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`coe_union` is a proof that `‚Üë(a ‚à™ b) = ‚Üëa ‚à™ ‚Üëb`. The `‚Üë` means type casting, which in this case\n"
"specifically means that if `a` is a `Finset`, then `‚Üëa` is a `Set` containing the same elements. This\n"
"theorem shows that type casting passes through unions."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`union_subset` is a proof that if `a ‚äÜ c` and `b ‚äÜ c`, then `a ‚à™ b ‚äÜ c`. This means that if you\n"
"have two sets that are subsets of the same set, their union is also a subset of that set."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`sum_add_distrib` is a proof that you can distribute addition over sums. This means that if\n"
"you have functions `f : A ‚Üí B`, and `g : A ‚Üí B`, and some set `s : Finset A`, then\n"
"`Finset.sum s (fun x => f x + g x) = Finset.sum s (fun x => f x) + Finset.sum s (fun x => g x)."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`sum_sub_distrib` is a proof that you can distribute subtraction over sums. This means that if\n"
"you have functions `f : A ‚Üí B`, and `g : A ‚Üí B`, and some set `s : Finset A`, then\n"
"`Finset.sum s (fun x => f x - g x) = Finset.sum s (fun x => f x) - Finset.sum s (fun x => g x)."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`Finset.subset_union_left` is a proof that if `a b : Finset S` are sets, then `a ‚äÜ a ‚à™ b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`Finset.subset_union_right` is a proof that if `a b : Finset S` are sets, then `b ‚äÜ a ‚à™ b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`sum_subset` is a proof that if you have a function that is zero outside of some set, then a sum\n"
"on a superset of that set is equal to a sum on that set. If you have a hypothesis `hSub : a ‚äÜ b`, another hypothesis\n"
"`hZero : ‚àÄ x ‚àà b, x ‚àâ a ‚Üí f x = 0`, then `sum_subset hSub hZero` is a proof that\n"
"`Finset.sum b f = Finset.sum a f`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`sub_smul` is a proof that subtraction distributes over scalar multiplication. `sub_smul a b c` is a proof\n"
"that `(a - b) ‚Ä¢ c = a ‚Ä¢ c - b ‚Ä¢ c`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`sub_eq_zero` is a proof that `a - b = 0` if and only if `a = b`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`not_mem_union` is the contrapositive of the definition of a union of sets. It states that if\n"
"`v ‚àâ a ‚à™ b`, then `v ‚àâ a ‚àß v ‚àâ b`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "`linear_combination_unique` is a proof that representation as a linear combination of a linearly independent\n"
"set of vectors is unique. It takes in two subsets of a linearly independent set, along with two functions\n"
"representing the linear combinations. The functions must be zero outside of the sets, and their sums\n"
"must be equal. In this case, this prooves that functions will be equal."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "First, note that you have a goal of proving two functions equal. Try to instead prove it for\n"
"an arbitrary value."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `funext v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now, we can split into cases where either v ‚àà (s ‚à™ t) or not."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `by_cases h : v ‚àà (s ‚à™ t)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `unfold linear_independent_v at hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Think about the forwards proof. What set and function are we summing over when applying the linear independence of S?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `specialize hS (s ‚à™ t) (f - g)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "We now want to show `‚Üë(s ‚à™ t) ‚äÜ S`. This is a type casted union. Instead, we want a union of\n"
"type casts, so that we can use theorems having to do with unions. One of the theorems should help with this"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `rw[coe_union] at hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `specialize hS (union_subset hs ht)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now, we have to show that `(Finset.sum (s ‚à™ t) fun v => (f - g) v ‚Ä¢ v) = 0`. This will\n"
"be difficult, so try proving it with a `have` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `have lemmaSumDiffEqZero : (Finset.sum (s ‚à™ t) fun v => (f - g) v ‚Ä¢ v) = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "It would be nice if we could distribute the `f - g` through the `‚Ä¢` operator. Try proving\n"
"`(fun v => (f - g) v ‚Ä¢ v) = (fun (v : V) => ((f v) ‚Ä¢ v) - ((g v) ‚Ä¢ v))` with another `have` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  have fun_dist : (fun v => (f - g) v ‚Ä¢ v) = (fun (v : V) => ((f v) ‚Ä¢ v) - ((g v) ‚Ä¢ v)) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    funext v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    exact sub_smul (f v) (g v) v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  rw[fun_dist]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now, we can split the sum in two"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  rw[sum_sub_distrib]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "We now have two sums. The first one should be equivalent to our first linear combination,\n"
"and the second should be equivalent to our second linear combination. We need to change the sets\n"
"they are being summed over. We have a theorem that can do this, but it needs a hypothesis that we\n"
"don't have. Try proving these hypotheses with a `have` statement."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  have hfprod0 : ‚àÄ v ‚àà s ‚à™ t,  v ‚àâ s ‚Üí f v ‚Ä¢ v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    intros v hv1 hv2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    rw[hf0 v hv2]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  have hgprod0 : ‚àÄ v ‚àà s ‚à™ t,  v ‚àâ t ‚Üí g v ‚Ä¢ v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    intros v hv1 hv2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    rw[hg0 v hv2]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `    exact zero_smul_v K V v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  rw [(sum_subset (f := fun v => f v ‚Ä¢ v) (subset_union_left s t) hfprod0).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  rw [(sum_subset (f := fun v => g v ‚Ä¢ v) (subset_union_right s t) hgprod0).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now, we use the fact that the two sums are equal to finish the proof of the lemma"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  rw[heq]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `  simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Now, we simply have to prove the requirements of hS"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `specialize hS lemmaSumDiffEqZero`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `specialize hS v h`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "We know now from hS that f v - g v = 0, and one of the new theorems lets us finish the proof.\n"
"Remember that if you have a proof of `‚Üî`, `.1` will be a proof of the forwards direction and `.2` the\n"
"backwards."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `exact sub_eq_zero.1 hS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `rw[not_mem_union] at h`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `cases' h with hS hT`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Try `rw[hf0 v hS, hg0 v hT]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level07
msgid "Congratulations! The next two levels are optional challenges, and although they are\n"
"difficult, if you were able to complete this level, you should be able to complete the next two."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Challenge Level - Linear Independence of Set with Insertion"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "This is your first challenge level! It is meant to be an optional challenge for those\n"
"who want to have more practice proving difficult theorems in Lean.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if you have some linearly independent set of vectors `S`, and\n"
"some vector `v ‚àâ span S`, then the set `S ‚à™ {v}` is also linearly independent.\n"
"\n"
"### How to skip the level\n"
"In this level, you will have access to the `sorry` tactic. This tactic is how you tell Lean \"I couldn't\n"
"finish the proof, but pretend like I did.\" Typing this tactic will always solve the goal, and allow\n"
"you to skip the level\n"
"\n"
"### Proof overview\n"
"Linear independence means that any linear combination that adds to zero must be all zeros. This means\n"
"that in order to show `S ‚à™ {v}` is linearly independent, you must introduce an arbitrary linear combination\n"
"with the function `f` over a set `s`. Here, you can consider whether `v ‚àà s` or not. If not, the proof\n"
"is simple, since `s` is a subset of `S` we already know `S` is linearly independent. If it is, we need\n"
"to prove `f(v) = 0`. This can be done since `v ‚àâ span S`, along with some clever choice of functions.\n"
"Once you have `f(v) = 0`, you can show that the function must be zero outside of `v` due to the linear\n"
"independence of `S`, which then shows `f` is zero on `s`.\n"
"\n"
"### New tactics/theorems\n"
"Similarly to the last level, there are new tactics and theorems you can read about to the right side.\n"
"Also, something that may be useful is the `‚Åª¬π` function. `x‚Åª¬π` is the multiplicative inverse of `x`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`sorry` allows you to skip levels. The `sorry` tactic will solve any goal, and although it is not actually\n"
"a proof, Lean treats it as one."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "## Summary\n"
"`by_contra` allows you to prove theorems by contradiction. When your goal is `P`, `by_contra h` will\n"
"create a hypothesis `h : ¬¨P` and change the goal to `False`.\n"
"\n"
"## Example\n"
"If your goal is `¬¨(isRational ‚àö2)`, using `by_contra h` will change the goal to `False`, and\n"
"give you a hypothesis `h : isRational ‚àö2`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "If you have some set s, where you know `h : i ‚àà s`, then `sum_eq_sum_diff_singleton_add h` is a proof that\n"
"`(Finset.sum s fun x => f x) = (Finset.sum (s \\ {i}) fun x => f x) + f i`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`smul_sum` is a proof that you can distribute scalar multiplication through `Finset.sum`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`inv_mul_cancel` is a proof that multiplying a nonzero inverse gives 1. If you have a hypothesis `h : x ‚â† 0`,\n"
"then  `inv_mul_cancel h` is a proof that `x‚Åª¬π * x = 1`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "`linear_independent_insert_of_not_in_span` is a proof that if you have a linearly independent set, and\n"
"you insert an element not in the span of that set, the new set is also linearly independent. The syntax\n"
"is as follows: if you have hypotheses `hS : linear_independent_v K V S`, and `hv_not_span : v ‚àâ span K V S`,\n"
"then `linear_independent_insert_of_not_in_span hS hv_not_span` is a proof of `linear_independent_v K V (S ‚à™ {v})`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "First, unfold the definitions, intro the variables and hypotheses we need, and simp where nescessary"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `unfold linear_independent_v at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `intros s f hs hf w hw`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp at hv_not_span`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We want to prove two seperate cases: v ‚àà s and v ‚àâ s. If v ‚àâ s, then we know s ‚äÜ S, so since S\n"
"is linearly independent, so is s. If v ‚àà s, then we have more work to do."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `by_cases hvIns : v ‚àà ¬´{s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we want to split ¬´{hf}¬ª into two, breaking off ¬´{v}¬ª so we have a sum over a subset of ¬´{S}¬ª"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw [sum_eq_sum_diff_singleton_add ¬´{hvIns}¬ª] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, that we have a sum over `(s \\ {v})`, we want to show `‚Üë(s \\ {v}) ‚äÜ S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have subset : ‚Üë(¬´{s}¬ª \\ {v}) ‚äÜ S := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `intros x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `cases' ¬´{hx}¬ª with xs xNev`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have xInUnion := ¬´{hs}¬ª ¬´{xs}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp at ¬´{xInUnion}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `cases' ¬´{xInUnion}¬ª with xEqv xInS`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{xNev}¬ª ¬´{xEqv}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{xInS}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can prove our important lemma, that `¬´{f}¬ª v = 0`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have lemma_fv_zero : ¬´{f}¬ª v = 0 := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "A good way to prove this is by contradiction"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `by_contra hfv_ne_zero`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "In order to use ¬´{hv_not_span}¬ª, we need to show ¬´{v}¬ª as a linear combination of a subset of ¬´{S}¬ª.\n"
"This can be done with a `have` statement."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have hvLinearCombo : v = (¬´{s}¬ª \\ {v}).sum (fun x => (-(¬´{f}¬ª v)‚Åª¬π * (¬´{f}¬ª x)) ‚Ä¢ x) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Not that the `simp only [theorem]` tactic allows us to rewrite using theorems inside a function, which cannot be done with just rw"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp only [mul_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, use some of the theorems we have to simplify the goal to an equality"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[(smul_sum (r := -(¬´{f}¬ª v)‚Åª¬π) (f := fun x => ¬´{f}¬ª x ‚Ä¢ x) (s := (¬´{s}¬ª \\ {v}))).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw [(neg_add_self ((¬´{f}¬ª v) ‚Ä¢ v)).symm] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[add_right_cancel ¬´{hf}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[(mul_smul (¬´{f}¬ª v)‚Åª¬π (¬´{f}¬ª v) v).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[inv_mul_cancel ¬´{hfv_ne_zero}¬ª, one_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can use ¬´{hv_not_span}¬ª to find our contradiction"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize ¬´{hv_not_span}¬ª (¬´{s}¬ª \\ {v})`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `specialize ¬´{hv_not_span}¬ª ¬´{subset}¬ª (fun x => -(¬´{f}¬ª v)‚Åª¬π * (¬´{f}¬ª x))`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{hv_not_span}¬ª ¬´{hvLinearCombo}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, consider two cases: `¬´{w}¬ª = ¬´{v}¬ª` or not. If `¬´{w}¬ª = ¬´{v}¬ª`, our lemma is our goal. If not,\n"
"we need to use the linear independence of `S`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `by_cases hw2 : ¬´{w}¬ª = v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw [¬´{hw2}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{lemma_fv_zero}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We can use our lemma to show that the sum of `¬´{f}¬ª` over `¬´{s}¬ª \\ {¬´{v}¬ª}` is equal to 0"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw[¬´{lemma_fv_zero}¬ª] at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp at ¬´{hf}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We want to show that `¬´{w}¬ª ‚àà ¬´{s}¬ª \\ {¬´{v}¬ª}`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have hwInS : ¬´{w}¬ª ‚àà ¬´{s}¬ª \\ {v} := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact hw`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact hw2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can apply all of our hypotheses to close the goal"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{hS}¬ª (¬´{s}¬ª \\ {v}) ¬´{f}¬ª ¬´{subset}¬ª ¬´{hf}¬ª ¬´{w}¬ª ¬´{hwInS}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "We now need to show that s ‚äÜ S, and we can use the linear independence of S to show s is linearly independent"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `have s_subset_S : ‚Üë¬´{s}¬ª ‚äÜ S := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `intro u hu_in_s`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `cases' ¬´{hs}¬ª ¬´{hu_in_s}¬ª with hu_in_S hu_eq_v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{hu_in_S}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `simp at ¬´{hu_eq_v}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `rw [¬´{hu_eq_v}¬ª] at ¬´{hu_in_s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exfalso`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{hvIns}¬ª ¬´{hu_in_s}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Now, we can use the linear independence of S to finish the proof"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level08
msgid "Try `exact ¬´{hS}¬ª ¬´{s}¬ª ¬´{f}¬ª ¬´{s_subset_S}¬ª ¬´{hf}¬ª ¬´{w}¬ª ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld
msgid "Linear Independence and Span World"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld
msgid "Welcome to Linear Independence and Span World! This world introduces the ideas of linear\n"
"independence/dependence and the span of a set of vectors. You will prove theorems, for example that\n"
"any subset of a linearly independent set of vectors is still linearly independent."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Challenge Level - Span After Removing Elements"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "This is the second challenge level, and the last level of the Linear Independence and Span World! Similar\n"
"to the first challenge level, this level is optional and can be skipped with the `sorry` tactic, but you can\n"
"play through it if you want more practice.\n"
"\n"
"### The Goal\n"
"The goal of this level is to prove that if you have some set `S`, and some vector `w` inside the span\n"
"of `S \\ {w}`, the span of `S` is the same as the span of `S \\ {w}`. This is because `w` can be written\n"
"as a sum of vectors of `S \\ {w}`, so any time you have `w` appear in a linear combination of `S`, you\n"
"can simply replace it with a sum of vectors in `S \\ {w}`.\n"
"\n"
"### Proof overview\n"
"The most difficult part of this proof is showing that given a linear representation of a vector in the\n"
"span of `S`, we can represent it as a sum of vectors in `S \\ {w}`. You are able to represent a sum over\n"
"`S` as a sum over `S \\ {w}` plus the function applied to `w`. Then, rewrite `w` as a sum of vectors\n"
"in `S \\ {w}`, and recombine the sums."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`subset_insert` is a proof that any set is a subset of itself with an element inserted. In Lean, the\n"
"syntax is as follows: if `s : Set T` is a set, and you have `x : T`, then `s ‚äÜ Set.insert x s`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`Finset.Subset.antisymm_iff` is a proof that two Finsets are equal if and only if they are subsets of each other."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`sum_eq_sum_diff_singleton_add` is a proof that if you have some set `s`, with `h : i ‚àà s`, then\n"
"`Finset.sum s (fun x => f x) = Finset.sum (s / {i}) (fun x => f x) + f i. The syntax is `sum_eq_sum_diff_singleton_add h f`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`mem_union_right` is a proof that if `a ‚àà t`, then `a ‚àà s ‚à™ t`. The syntax is `mem_union_right s h`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`subset_diff_singleton` is a proof that if `h : s ‚äÜ t`, and `hx : x ‚àâ s`, then `s ‚äÜ t \\ {x}`. The syntax\n"
"is `subset_diff_singleton h hx`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`diff_subset` is a proof that `s ‚äÜ s \\ t`. The syntax is `diff_subset s t`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "## Summary\n"
"`tauto` solves goals using simple logic. It works similarly to the `simp` and `linarith` tactics, in\n"
"that there is not just one use case. If there is a contradiction that can be easily inferred, or if\n"
"the goal is a direct result of the hypotheses, `tauto` will solve the goal.\n"
"\n"
"## Example\n"
"If your goal is of the form `P ‚à® ¬¨P`, then `tauto will solve the goal.\n"
"\n"
"## Example\n"
"If your goal is of the form `A ‚à® B`, and you have a hypothesis `h : A ‚à® (B ‚àß C)`, then `tauto` will\n"
"solve the goal."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "## Summary\n"
"`left` is one of the ways of proving `or` statements. If your goal is `P ‚à® Q`, then `left` changes the\n"
"goal to `P`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "## Summary\n"
"`right` is one of the ways of proving `or` statements. If your goal is `P ‚à® Q`, then `right` changes the\n"
"goal to `Q`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "## Summary\n"
"`let` acts very similarly to `have`. Instead of allowing you to create new hypotheses, `let` allows you\n"
"to create new objects.\n"
"\n"
"## Using `rw` after `let` statements\n"
"You may want to use `rw` with the equalities you choose in a `let` statement. To do this, you must create\n"
"a new lemma stating this equality with `have`. The proof will simply be `rfl`.\n"
"\n"
"## Example\n"
"If you have objects `x y : V`, then you can say `let z := x + y`, and you will have a new object `z`,\n"
"where `z = x + y` can be solvedd by `rfl`\n"
"\n"
"## Example\n"
"If you have a function `f : V ‚Üí K`, and `v : V`, you can say `let f := fun x => f x ‚Ä¢ v`."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "`ite` stands for `if then else`. If is used when creating functions. You can think of `ite P f1 f2` as\n"
"\"If P then f1 else f2\". This function gives you f1 when P is True, and f2 otherwise. This can help you\n"
"design functions that are 0 outside of certain sets."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid ""
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "We want to prove two sets are equal. What theorem can help us with this?"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `apply Set.eq_of_subset_of_subset`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "First, introduce an arbitrary element, unfold definitions and simp"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `unfold span at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `unfold is_linear_combination at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at *`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we have two helpful statements. We can use `obtain` to get sets and functions from them"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `obtain ‚ü®sw, hsw, fw, hfw‚ü© := hcomb`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `obtain ‚ü®sx, hsx, fx, hfx‚ü© := ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Here, we can split into two cases: whether or not `w ‚àà ¬´{sx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `by_cases hw : w ‚àà ¬´{sx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "What set should we be summing over? Note that you have two different sets where functions are\n"
"defined, ¬´{sw}¬ª and ¬´{sx}¬ª"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `use ¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[coe_union]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `apply Set.union_subset ¬´{hsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact subset_trans ¬´{hsx}¬ª (subset_insert w S)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "In order to manipulate the sum better, it would be nice to rewrite the set you are summing over.\n"
"You can use a `have` statement to show that this set is equal to `(¬´{sw}¬ª ‚à™ ¬´{sw}¬ª \\ {w})`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have set_eq : ¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w}) = (¬´{sw}¬ª ‚à™ ¬´{sx}¬ª) \\ {w} := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `apply Finset.Subset.antisymm_iff.2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `tauto`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{hx}¬ª with hInsw hInsx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intro hEqW`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hEqW}¬ª] at ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hContra := ¬´{hsw}¬ª ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try simp at ¬´{hContra}¬ª``"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hInsx}¬ª.2`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `intro x hx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp at ¬´{hx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{hx}¬ª with hl hr`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `cases' ¬´{hl}¬ª with hInsw hInsx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `left`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hInsw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `right`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hInsx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exacr ¬´{hr}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, let's consider the function we will be summing. To get a sum of `¬´{x}¬ª`, we need two parts:\n"
"the sum over `S` getting `¬´{x}¬ª`, and the sum over `S \\ {w}` to get `w`. This can be thought of as\n"
"two seperate functions. The first function will be similar to `¬´{fx}¬ª`, but since we do not know what\n"
"`¬´{fx}¬ª` is outside of `¬´{sx}¬ª`, we must make this function `0` outside of `sx`. We can define this first\n"
"function with a `let` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `let fx' := fun v => (ite (v ‚àà ¬´{sx}¬ª) (¬´{fx}¬ª v) 0)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hfx' : ¬´{fx'}¬ª = (fun v => (ite (v ‚àà ¬´{sx}¬ª) (¬´{fx}¬ª v) 0)) := rfl`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, you can prove that summing `¬´{fx'}¬ª` over our set gives the correct value. Prove this with\n"
"a `have` statement"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have fx'_sum : ¬´{x}¬ª - (¬´{fx}¬ª w ‚Ä¢ w) = (¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})).sum (fun v => ¬´{fx'}¬ª v ‚Ä¢ v) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[set_eq]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `apply add_right_cancel (b := ¬´{fx}¬ª w ‚Ä¢ w)`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hfx'w : ¬´{fx}¬ª w = ¬´{fx'}¬ª w := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hfx'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp only [¬´{hw}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hfx'w}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[(sum_eq_sum_diff_singleton_add (mem_union_right ¬´{sw}¬ª ¬´{hw}¬ª) (fun v => ¬´{fx'}¬ª v ‚Ä¢ v)).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hfx'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact ¬´{hfx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we can create the second function, which will be added to get the missing `¬´{fx}¬ª w ‚Ä¢ w`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `let fw' := fun v => ite (v ‚àà ¬´{sw}¬ª) (¬´{fx}¬ª w * ¬´{fw}¬ª v) 0`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have hfw' : ¬´{fw'}¬ª = (fun v => ite (v ‚àà ¬´{sw}¬ª) (¬´{fx}¬ª w * ¬´{fw}¬ª v) 0) := rfl`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Again, prove that the function sums to the correct value"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `have fw'_sum : ¬´{fx}¬ª w ‚Ä¢ w = (¬´{sw}¬ª ‚à™ (¬´{sx}¬ª \\ {w})).sum (fun v => ¬´{fw'}¬ª v ‚Ä¢ v) := by`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hfw'}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp only [mul_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[(smul_sum (r := ¬´{fx}¬ª w) (s := ¬´{sw}¬ª) (f := fun v => ¬´{fw}¬ª v ‚Ä¢ v)).symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[¬´{hfw}¬ª]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, use the functions we have defined"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `use fun v => ¬´{fx'}¬ª v + ¬´{fw'}¬ª v`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp only [add_smul]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `rw[sum_add_distrib, ¬´{fx'_sum}¬ª.symm, ¬´{fw'_sum}¬ª.symm]`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `simp`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Now, we are on the second case, when `w ‚àâ ¬´{sx}¬ª."
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `use ¬´{sx}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `constructor`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact subset_diff_singleton ¬´{hsx}¬ª ¬´{hw}¬ª`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `use fx`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Lastly, we must prove that `span K V (S \\ {w}) ‚äÜ span K V S`. This is simple with span_mono"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `apply span_mono`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "Try `exact diff_subset S {w}`"
msgstr ""

#: Game.Levels.LinearIndependenceSpanWorld.Level09
msgid "You have now finished the Linear Independence and Span World!"
msgstr ""

#: Game
msgid "Linear Algebra Game"
msgstr ""

#: Game
msgid "# Welcome to the Linear Algebra Game!\n"
"\n"
"This game works as a learning tool for linear algebra,\n"
"based on the textbook \"Linear Algebra Done Right\" by Sheldon Axler. It also serves as an\n"
"introduction to Lean 4, a proof assistant that provides an environment to encode proofs formally.\n"
"\n"
"Proofs in Lean can are written in precise syntax, using tactics and theorems, and can be algorithmically\n"
"checked for correctness by a computer.\n"
"\n"
"This game covers many areas of linear algebra, including vector spaces, linear independence, bases,\n"
"linear mappings, and isomorphisms.\n"
"\n"
"To start, click on \"Tutorial World\""
msgstr ""

#: Game
msgid "*Game version: 1.0*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Team:** Huiyu Chen, Adam Kern, Justin Morrill, and Letian Yang\n"
"* **Project Manager:** Daniel Zhou\n"
"* **Project Leader:** Professor Colleen Robles\n"
"* **2023 Lean 3 Version:** Yannan Bai, Annapurna Bhattacharya, Chun-Hsien Hsu, Stavan Jain, Kurt Ma, Ricardo Prado Cunha, Anoushka Sinha (Project Manager: Chun-Hsien Hsu)\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Inspiration:** Kevin Buzzard's Natural Number Game (https://adam.math.hhu.de/#/g/leanprover-community/nng4)"
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
